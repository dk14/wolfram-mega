{
  "version": 3,
  "sources": ["../node_modules/@nyariv/sandboxjs/src/utils.ts", "../node_modules/@nyariv/sandboxjs/src/executor.ts", "../node_modules/@nyariv/sandboxjs/src/unraw.ts", "../node_modules/@nyariv/sandboxjs/src/parser.ts", "../node_modules/@nyariv/sandboxjs/src/eval.ts", "../node_modules/@nyariv/sandboxjs/src/SandboxExec.ts", "../node_modules/@nyariv/sandboxjs/src/Sandbox.ts", "../node_modules/async-mutex/index.mjs", "../src-web/dsl.ts", "../src-web/util/dsl-runtime.ts"],
  "sourcesContent": ["import { IEvalContext } from './eval';\nimport { Change, Unknown } from './executor';\nimport { IConstants, IExecutionTree, Lisp, LispItem } from './parser';\nimport SandboxExec from './SandboxExec';\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any;\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (\n    ticks: Ticks,\n    scope: Scope,\n    context: IExecutionTree,\n    tree: LispItem\n  ) => boolean | void;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<new () => any, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (\n    ticks: Ticks,\n    scope: Scope,\n    context: IExecutionTree,\n    tree: LispItem\n  ) => boolean | void;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: { [name: string]: Set<string> };\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext;\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  >;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext;\n}\n\nexport interface ISandboxGlobal {\n  [key: string]: unknown;\n}\ninterface SandboxGlobalConstructor {\n  new (globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  if (globals === (globalThis as any)) return globalThis;\n  for (const i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor;\n\nexport type IGlobals = ISandboxGlobal;\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Set<(modification: Change) => void>\n    >,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext\n  ) {}\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal,\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as Object, new Set());\n  return context;\n}\n\nexport function createExecContext(\n  sandbox: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n    sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>;\n    context: IContext;\n  },\n  executionTree: IExecutionTree,\n  evalContext?: IEvalContext\n): IExecContext {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    evals.set(Function, func);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func));\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  start: number;\n  end: number;\n  ref: { str: string };\n  constructor(str: string | CodeString) {\n    this.ref = { str: '' };\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start;\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length() {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (const key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'throw',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case',\n]);\n\nexport const enum VarType {\n  let = 'let',\n  const = 'const',\n  var = 'var',\n}\n\nexport class Scope {\n  parent: Scope | null;\n  const: { [key: string]: true } = {};\n  let: { [key: string]: true } = {};\n  var: { [key: string]: true } = {};\n  globals: { [key: string]: true };\n  allVars: { [key: string]: unknown } & Object;\n  functionThis?: Unknown;\n  constructor(parent: Scope | null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    const functionThis = this.functionThis;\n    if (key === 'this' && functionThis !== undefined) {\n      return new Prop({ this: functionThis }, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(\n          this.allVars,\n          key,\n          this.const.hasOwnProperty(key),\n          this.globals.hasOwnProperty(key),\n          true\n        );\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope);\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const prop = this.get(key);\n    if (prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    if (!(prop.context instanceof Object)) throw new SandboxError('Scope is not an object');\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal);\n    } else if (\n      (this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) ||\n      !(key in this.allVars)\n    ) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem | LispItem): item is Type {\n  return (\n    Array.isArray(item) &&\n    typeof item[0] === 'number' &&\n    item[0] !== LispType.None &&\n    item[0] !== LispType.True\n  );\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n\n  LispEnumSize,\n}\n\nexport class Prop {\n  constructor(\n    public context: Unknown,\n    public prop: string,\n    public isConst = false,\n    public isGlobal = false,\n    public isVariable = false\n  ) {}\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    if (ctx === null)\n      throw new TypeError(`Cannot read properties of null, (reading '${this.prop}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop));\n    return (ctx as any)[this.prop] as T;\n  }\n}\n", "import { LispItem, Lisp, IRegEx, LispFamily, ExtractLispOp, SwitchCase } from './parser.js';\nimport {\n  CodeString,\n  IAuditReport,\n  IExecContext,\n  IScope,\n  isLisp,\n  LispType,\n  LocalScope,\n  Prop,\n  SandboxError,\n  Scope,\n  Ticks,\n  VarType,\n} from './utils.js';\n\nexport type Done<T = any> = (err?: any, res?: T | typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(\n    public auditReport: IAuditReport | undefined,\n    public result: T,\n    public returned: boolean,\n    public breakLoop = false,\n    public continueLoop = false\n  ) {}\n}\n\nexport type Unknown = undefined | null | Record<string | number, unknown>;\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: 'create';\n  prop: number | string;\n}\n\nexport interface IReplace extends IChange {\n  type: 'replace';\n}\n\nexport interface IDelete extends IChange {\n  type: 'delete';\n  prop: number | string;\n}\n\nexport interface IReverse extends IChange {\n  type: 'reverse';\n}\n\nexport interface ISort extends IChange {\n  type: 'sort';\n}\n\nexport interface IPush extends IChange {\n  type: 'push';\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: 'pop';\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: 'shift';\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: 'unshift';\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: 'splice';\n  startIndex: number;\n  deleteCount: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport interface ICopyWithin extends IChange {\n  type: 'copyWithin';\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change =\n  | ICreate\n  | IReplace\n  | IDelete\n  | IReverse\n  | ISort\n  | IPush\n  | IPop\n  | IUnShift\n  | IShift\n  | ISplice\n  | ICopyWithin;\n\nconst optional = {};\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport const sandboxedFunctions = new WeakSet();\nexport function createFunction(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError('Function creation is forbidden');\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)]\n      );\n      return res.result;\n    };\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)]\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError('Function creation is forbidden');\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError('Async/await not permitted');\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)]\n      );\n      return res.result;\n    };\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)]\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if (obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`);\n  }\n  if (typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`);\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === 'delete') {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop }));\n      context.changeSubscriptionsGlobal\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop }));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions\n      .get(obj.context)\n      ?.get(obj.prop)\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        })\n      );\n    context.setSubscriptionsGlobal\n      .get(obj.context)\n      ?.get(obj.prop)\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        })\n      );\n  } else {\n    context.changeSubscriptions\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop }));\n    context.changeSubscriptionsGlobal\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop }));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin,\n]);\n\nexport class KeyVal {\n  constructor(public key: string | SpreadObject, public val: unknown) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: { [key: string]: unknown }) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(public t: Lisp, public f: Lisp) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  a: any,\n  b: any,\n  obj: any,\n  context: IExecContext,\n  scope: Scope,\n  bobj?: any,\n  inLoopOrSwitch?: string\n) => void;\n\nexport const ops = new Map<LispType, OpCallback>();\nexport function addOps<Type extends LispFamily>(type: ExtractLispOp<Type>, cb: OpCallback) {\n  ops.set(type, cb);\n}\n\naddOps(LispType.Prop, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  if (a === null) {\n    throw new TypeError(`Cannot get property ${b} of null`);\n  }\n  const type = typeof a;\n  if (type === 'undefined' && obj === undefined) {\n    const prop = scope.get(b);\n    if (prop.context === context.ctx.sandboxGlobal) {\n      if (context.ctx.options.audit) {\n        context.ctx.auditReport?.globalsAccess.add(b);\n      }\n      const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b])\n        ? context.evals.get(context.ctx.sandboxGlobal[b])\n        : undefined;\n      if (rep) {\n        done(undefined, rep);\n        return;\n      }\n    }\n    if (prop.context && prop.context[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    done(undefined, prop);\n    return;\n  } else if (a === undefined) {\n    throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\");\n  }\n\n  if (type !== 'object') {\n    if (type === 'number') {\n      a = new Number(a);\n    } else if (type === 'string') {\n      a = new String(a);\n    } else if (type === 'boolean') {\n      a = new Boolean(a);\n    }\n  } else if (typeof a.hasOwnProperty === 'undefined') {\n    done(undefined, new Prop(undefined, b));\n    return;\n  }\n\n  const isFunction = type === 'function';\n  const prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n  if (context.ctx.options.audit && prototypeAccess) {\n    if (typeof b === 'string') {\n      let prot = Object.getPrototypeOf(a);\n      do {\n        if (prot.hasOwnProperty(b)) {\n          if (\n            context.ctx.auditReport &&\n            !context.ctx.auditReport.prototypeAccess[prot.constructor.name]\n          ) {\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n          }\n          context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n        }\n      } while ((prot = Object.getPrototypeOf(prot)));\n    }\n  }\n\n  if (prototypeAccess) {\n    if (isFunction) {\n      if (!['name', 'length', 'constructor'].includes(b) && (a.hasOwnProperty(b) || b === '__proto__')) {\n        const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n        const replace = context.ctx.options.prototypeReplacements.get(a);\n        if (replace) {\n          done(undefined, new Prop(replace(a, true), b));\n          return;\n        }\n        if (!(whitelist && (!whitelist.size || whitelist.has(b)))) {\n          throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n        }\n      }\n    } else if (b !== 'constructor') {\n      let prot = a;\n      while ((prot = Object.getPrototypeOf(prot))) {\n        if (prot.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(prot);\n          const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n          if (replace) {\n            done(undefined, new Prop(replace(a, false), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n            break;\n          }\n          throw new SandboxError(\n            `Method or property access not permitted: ${prot.constructor.name}.${b}`\n          );\n        }\n      }\n    }\n  }\n\n  if (context.evals.has(a[b])) {\n    done(undefined, context.evals.get(a[b]));\n    return;\n  }\n  if (a[b] === globalThis) {\n    done(undefined, context.ctx.globalScope.get('this'));\n    return;\n  }\n\n  const g =\n    obj.isGlobal ||\n    (isFunction && !sandboxedFunctions.has(a)) ||\n    context.ctx.globalsWhitelist.has(a);\n\n  done(undefined, new Prop(a, b, false, g));\n});\n\naddOps(LispType.Call, (exec, done, ticks, a, b: Lisp[], obj, context) => {\n  if (context.ctx.options.forbidFunctionCalls)\n    throw new SandboxError('Function invocations are not allowed');\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    done(undefined, obj(...vals));\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (const y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (\n    obj.context instanceof Array &&\n    arrayChange.has(obj.context[obj.prop]) &&\n    (context.changeSubscriptions.get(obj.context) ||\n      context.changeSubscriptionsGlobal.get(obj.context))\n  ) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === 'push') {\n      change = {\n        type: 'push',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'pop') {\n      change = {\n        type: 'pop',\n        removed: obj.context.slice(-1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'shift') {\n      change = {\n        type: 'shift',\n        removed: obj.context.slice(0, 1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'unshift') {\n      change = {\n        type: 'unshift',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'splice') {\n      change = {\n        type: 'splice',\n        startIndex: vals[0],\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1]),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === 'reverse' || obj.prop === 'sort') {\n      change = { type: obj.prop };\n      changed = !!obj.context.length;\n    } else if (obj.prop === 'copyWithin') {\n      const len =\n        vals[2] === undefined\n          ? obj.context.length - vals[1]\n          : Math.min(obj.context.length, vals[2] - vals[1]);\n      change = {\n        type: 'copyWithin',\n        startIndex: vals[0],\n        endIndex: vals[0] + len,\n        added: obj.context.slice(vals[1], vals[1] + len),\n        removed: obj.context.slice(vals[0], vals[0] + len),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  done(undefined, obj.context[obj.prop](...vals));\n});\n\naddOps(LispType.CreateObject, (exec, done, ticks, a, b: KeyVal[]) => {\n  let res = {} as any;\n  for (const item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = { ...res, ...item.key.item };\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps(LispType.KeyVal, (exec, done, ticks, a: string, b: LispItem) =>\n  done(undefined, new KeyVal(a, b))\n);\n\naddOps(LispType.CreateArray, (exec, done, ticks, a, b: Lisp[], obj, context) => {\n  const items = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n  done(undefined, items);\n});\n\naddOps(LispType.Group, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.GlobalSymbol, (exec, done, ticks, a, b: string) => {\n  switch (b) {\n    case 'true':\n      return done(undefined, true);\n    case 'false':\n      return done(undefined, false);\n    case 'null':\n      return done(undefined, null);\n    case 'undefined':\n      return done(undefined, undefined);\n    case 'NaN':\n      return done(undefined, NaN);\n    case 'Infinity':\n      return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b));\n});\n\naddOps(LispType.Number, (exec, done, ticks, a, b) => done(undefined, Number(b)));\naddOps(LispType.BigInt, (exec, done, ticks, a, b) => done(undefined, BigInt(b)));\naddOps(LispType.StringIndex, (exec, done, ticks, a, b: string, obj, context) =>\n  done(undefined, context.constants.strings[parseInt(b)])\n);\n\naddOps(LispType.RegexIndex, (exec, done, ticks, a, b: string, obj, context) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxError('Regex not permitted');\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps(LispType.LiteralIndex, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  const item = context.constants.literals[parseInt(b)];\n  const [, name, js] = item;\n  const found: Lisp[] = [];\n  let f: RegExpExecArray | null;\n  const resnums: string[] = [];\n  while ((f = literalRegex.exec(name))) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if (err) {\n      done(err);\n      return;\n    }\n    for (const i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(\n      undefined,\n      name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        const res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      })\n    );\n  });\n});\n\naddOps(LispType.SpreadArray, (exec, done, ticks, a, b) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps(LispType.SpreadObject, (exec, done, ticks, a, b) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps(LispType.Not, (exec, done, ticks, a, b) => done(undefined, !b));\naddOps(LispType.Inverse, (exec, done, ticks, a, b) => done(undefined, ~b));\n\naddOps(LispType.IncrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps(LispType.IncrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps(LispType.DecrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps(LispType.DecrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps(LispType.Assign, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] = b));\n});\n\naddOps(LispType.AddEquals, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] += b));\n});\n\naddOps(LispType.SubractEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] -= b));\n});\n\naddOps(LispType.DivideEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] /= b));\n});\n\naddOps(LispType.MultiplyEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] *= b));\n});\n\naddOps(LispType.PowerEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] **= b));\n});\n\naddOps(LispType.ModulusEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] %= b));\n});\n\naddOps(LispType.BitNegateEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] ^= b));\n});\n\naddOps(LispType.BitAndEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] &= b));\n});\n\naddOps(LispType.BitOrEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] |= b));\n});\n\naddOps(LispType.ShiftLeftEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] <<= b));\n});\n\naddOps(LispType.ShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps(LispType.UnsignedShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps(LispType.LargerThan, (exec, done, ticks, a, b) => done(undefined, a > b));\naddOps(LispType.SmallerThan, (exec, done, ticks, a, b) => done(undefined, a < b));\naddOps(LispType.LargerEqualThan, (exec, done, ticks, a, b) => done(undefined, a >= b));\naddOps(LispType.SmallerEqualThan, (exec, done, ticks, a, b) => done(undefined, a <= b));\naddOps(LispType.Equal, (exec, done, ticks, a, b) => done(undefined, a == b));\naddOps(LispType.StrictEqual, (exec, done, ticks, a, b) => done(undefined, a === b));\naddOps(LispType.NotEqual, (exec, done, ticks, a, b) => done(undefined, a != b));\naddOps(LispType.StrictNotEqual, (exec, done, ticks, a, b) => done(undefined, a !== b));\naddOps(LispType.And, (exec, done, ticks, a, b) => done(undefined, a && b));\naddOps(LispType.Or, (exec, done, ticks, a, b) => done(undefined, a || b));\naddOps(LispType.BitAnd, (exec, done, ticks, a: number, b: number) => done(undefined, a & b));\naddOps(LispType.BitOr, (exec, done, ticks, a: number, b: number) => done(undefined, a | b));\naddOps(LispType.Plus, (exec, done, ticks, a: number, b: number) => done(undefined, a + b));\naddOps(LispType.Minus, (exec, done, ticks, a: number, b: number) => done(undefined, a - b));\naddOps(LispType.Positive, (exec, done, ticks, a, b) => done(undefined, +b));\naddOps(LispType.Negative, (exec, done, ticks, a, b) => done(undefined, -b));\naddOps(LispType.Divide, (exec, done, ticks, a: number, b: number) => done(undefined, a / b));\naddOps(LispType.BitNegate, (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b));\naddOps(LispType.Multiply, (exec, done, ticks, a: number, b: number) => done(undefined, a * b));\naddOps(LispType.Modulus, (exec, done, ticks, a: number, b: number) => done(undefined, a % b));\naddOps(LispType.BitShiftLeft, (exec, done, ticks, a: number, b: number) => done(undefined, a << b));\naddOps(LispType.BitShiftRight, (exec, done, ticks, a: number, b: number) =>\n  done(undefined, a >> b)\n);\naddOps(LispType.BitUnsignedShiftRight, (exec, done, ticks, a: number, b: number) =>\n  done(undefined, a >>> b)\n);\naddOps(LispType.Typeof, (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n  exec(ticks, b, scope, context, (e, prop) => {\n    done(undefined, typeof valueOrProp(prop, context));\n  });\n});\n\naddOps(LispType.Instanceof, (exec, done, ticks, a, b: { new (): unknown }) =>\n  done(undefined, a instanceof b)\n);\naddOps(LispType.In, (exec, done, ticks, a: string, b) => done(undefined, a in b));\n\naddOps(LispType.Delete, (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n  if (bobj.context === undefined) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete bobj.context?.[bobj.prop]);\n});\n\naddOps(LispType.Return, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.Var, (exec, done, ticks, a: string, b: LispItem, obj, context, scope) => {\n  done(undefined, scope.declare(a, VarType.var, b));\n});\n\naddOps(LispType.Let, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj && bobj.isGlobal));\n});\n\naddOps(LispType.Const, (exec, done, ticks, a: string, b: LispItem, obj, context, scope) => {\n  done(undefined, scope.declare(a, VarType.const, b));\n});\n\naddOps(\n  LispType.ArrowFunction,\n  (exec, done, ticks, a: string[], b: Lisp[], obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  }\n);\n\naddOps(\n  LispType.Function,\n  (exec, done, ticks, a: (string | LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  }\n);\n\naddOps(\n  LispType.InlineFunction,\n  (exec, done, ticks, a: (string | LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    if (name) {\n      scope = new Scope(scope, {});\n    }\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  }\n);\n\naddOps(LispType.Loop, (exec, done, ticks, a: Lisp[], b: Lisp[], obj, context, scope) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  const internalVars = {\n    $$obj: undefined,\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async () => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] =\n        (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst)\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      while (loop) {\n        const innerLoopVars = {};\n        ad = asyncDone((d) =>\n          exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d)\n        );\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        const res = await executeTreeAsync(\n          ticks,\n          context,\n          b,\n          [new Scope(loopScope, innerLoopVars)],\n          'loop'\n        );\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    while (loop) {\n      const innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      const res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], 'loop');\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    }\n    done();\n  }\n});\n\naddOps(\n  LispType.LoopAction,\n  (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === 'switch' && a === 'continue') || !inLoopOrSwitch) {\n      throw new SandboxError('Illegal ' + a + ' statement');\n    }\n    done(\n      undefined,\n      new ExecReturn(context.ctx.auditReport, undefined, false, a === 'break', a === 'continue')\n    );\n  }\n);\n\naddOps(\n  LispType.If,\n  (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n    exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n  }\n);\n\naddOps(LispType.InlineIf, (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\naddOps(LispType.InlineIfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\naddOps(LispType.IfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\n\naddOps(LispType.Switch, (exec, done, ticks, a: LispItem, b: SwitchCase[], obj, context, scope) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (const caseItem of b) {\n        if (\n          isTrue ||\n          (isTrue =\n            !caseItem[1] ||\n            toTest ===\n              valueOrProp(\n                syncDone((d) => exec(ticks, caseItem[1], scope, context, d)).result,\n                context\n              ))\n        ) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], 'switch');\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) {\n            // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (const caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (\n            isTrue ||\n            (isTrue =\n              !caseItem[1] ||\n              toTest ===\n                valueOrProp(\n                  (ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant ===\n                    true\n                    ? ad.instant\n                    : (await ad.p).result,\n                  context\n                ))\n          ) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], 'switch');\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) {\n              // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done);\n    }\n  });\n});\n\naddOps(\n  LispType.Try,\n  (\n    exec,\n    done,\n    ticks,\n    a: Lisp[],\n    b: [string, Lisp[], Lisp[]],\n    obj,\n    context,\n    scope,\n    bobj,\n    inLoopOrSwitch\n  ) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(\n      exec,\n      (err, res) => {\n        executeTreeWithDone(\n          exec,\n          (e) => {\n            if (e) done(e);\n            else if (err) {\n              const sc: Record<string, unknown> = {};\n              if (exception) sc[exception] = err;\n              executeTreeWithDone(\n                exec,\n                done,\n                ticks,\n                context,\n                catchBody,\n                [new Scope(scope)],\n                inLoopOrSwitch\n              );\n            } else {\n              done(undefined, res);\n            }\n          },\n          ticks,\n          context,\n          finallyBody,\n          [new Scope(scope, {})]\n        );\n      },\n      ticks,\n      context,\n      a,\n      [new Scope(scope)],\n      inLoopOrSwitch\n    );\n  }\n);\n\naddOps(LispType.Void, (exec, done) => {\n  done();\n});\naddOps(\n  LispType.New,\n  (exec, done, ticks, a: new (...args: unknown[]) => unknown, b: unknown[], obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`);\n    }\n    done(undefined, new a(...b));\n  }\n);\n\naddOps(LispType.Throw, (exec, done, ticks, a, b) => {\n  done(b);\n});\naddOps(LispType.Expression, (exec, done, ticks, a: unknown[]) => done(undefined, a.pop()));\naddOps(LispType.None, (exec, done) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): any {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(\n  ticks: Ticks,\n  exec: Execution,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res =\n        (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string\n) => void;\n\nexport interface AsyncDoneRet {\n  isInstant: boolean;\n  instant: any;\n  p: Promise<{ result: any }>;\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({ result });\n      }\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p,\n  };\n}\n\nexport function syncDone(callback: (done: Done) => void): { result: any } {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return { result };\n}\n\nexport async function execAsync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  doneOriginal: Done<T>,\n  inLoopOrSwitch?: string\n): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    };\n  });\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\nexport function execSync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string\n) {\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof,\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  isAsync: boolean,\n  inLoopOrSwitch?: string\n): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota && context.ctx.options.executionQuota <= ticks.ticks) {\n    if (\n      !(\n        typeof context.ctx.options.onExecutionQuotaReached === 'function' &&\n        context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)\n      )\n    ) {\n      done(new SandboxError('Execution quota exceeded'));\n      return true;\n    }\n  }\n  ticks.ticks++;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(\n        ticks,\n        tree[1],\n        scope,\n        context,\n        async (e, r) => {\n          if (e) done(e);\n          else\n            try {\n              done(undefined, await valueOrProp(r, context));\n            } catch (err) {\n              done(err);\n            }\n        },\n        inLoopOrSwitch\n      ).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'));\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    try {\n      ops.get(tree[0])?.(\n        exec,\n        done,\n        ticks,\n        tree[1],\n        tree[2],\n        tree,\n        context,\n        scope,\n        undefined,\n        inLoopOrSwitch\n      );\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n): ExecReturn<T> {\n  return syncDone((done) =>\n    executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)\n  ).result;\n}\n\nexport async function executeTreeAsync<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) =>\n    executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)\n  )).isInstant === true\n    ? ad.instant\n    : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n) {\n  if (!executionTree) {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while ((s = scopes.shift())) {\n    if (typeof s !== 'object') continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    };\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n", "/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex: string, errorName: string, enforcedLength?: number): number {\n  const parsedHex = parseHexToInt(hex);\n  if (Number.isNaN(parsedHex) || (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Hexadecimal', 2);\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(surrogateCode, 'Malformed Unicode', 4);\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === '{' && text.charAt(text.length - 1) === '}';\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(withoutBraces, 'Malformed Unicode');\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError ? new SyntaxError('Code Point Limit:' + parsedCode) : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  ['b', '\\b'],\n  ['f', '\\f'],\n  ['n', '\\n'],\n  ['r', '\\r'],\n  ['t', '\\t'],\n  ['v', '\\v'],\n  ['0', '\\0'],\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch =\n  /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(\n    escapeMatch,\n    function (\n      _,\n      backslash?: string,\n      hex?: string,\n      codePoint?: string,\n      unicodeWithSurrogate?: string,\n      surrogate?: string,\n      unicode?: string,\n      octal?: string,\n      singleCharacter?: string\n    ): string {\n      // Compare groups to undefined because empty strings mean different errors\n      // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n      if (backslash !== undefined) {\n        return '\\\\';\n      }\n      if (hex !== undefined) {\n        return parseHexadecimalCode(hex);\n      }\n      if (codePoint !== undefined) {\n        return parseUnicodeCodePointCode(codePoint);\n      }\n      if (unicodeWithSurrogate !== undefined) {\n        return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n      }\n      if (unicode !== undefined) {\n        return parseUnicodeCode(unicode);\n      }\n      if (octal === '0') {\n        return '\\0';\n      }\n      if (octal !== undefined) {\n        throw new SyntaxError('Octal Deprecation: ' + octal);\n      }\n      if (singleCharacter !== undefined) {\n        return parseSingleCharacterCode(singleCharacter);\n      }\n      throw new SyntaxError('End of string');\n    }\n  );\n}\nexport default unraw;\n", "import unraw from './unraw.js';\nimport { CodeString, isLisp, LispType } from './utils.js';\n\nexport type DefineLisp<\n  op extends LispType,\n  a extends LispItem | LispItem,\n  b extends LispItem | LispItem\n> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None | LispType.True | string | Lisp;\nexport type LispItem = LispItemSingle | LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {\n  op: ExtractLispOp<L>;\n  a: ExtractLispA<L>;\n  b: ExtractLispB<L>;\n}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({ op: LispType.None, a: LispType.None, b: LispType.None });\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & { tempJsStrings?: string[] };\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>;\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>;\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>;\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>;\nexport type KeyVal = DefineLisp<LispType.KeyVal, string | Lisp, Lisp>;\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string | Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None | Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp | LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp | LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp | LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<\n  LispType.Function,\n  (string | LispType.None | LispType.True)[],\n  string | Lisp[]\n>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string | Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string | Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily =\n  | Literal\n  | If\n  | InlineIf\n  | IfCase\n  | InlineIfCase\n  | KeyVal\n  | SpreadObject\n  | SpreadArray\n  | ArrayProp\n  | Prop\n  | PropOptional\n  | Call\n  | CallOptional\n  | CreateArray\n  | CreateObject\n  | Group\n  | Inverse\n  | Not\n  | Negative\n  | Positive\n  | Typeof\n  | Delete\n  | IncrementBefore\n  | IncrementAfter\n  | DecrementBefore\n  | DecrementAfter\n  | And\n  | Or\n  | Instanceof\n  | In\n  | Assigns\n  | SubractEquals\n  | AddEquals\n  | DivideEquals\n  | PowerEquals\n  | MultiplyEquals\n  | ModulusEquals\n  | BitNegateEquals\n  | BitAndEquals\n  | BitOrEquals\n  | UnsignedShiftRightEquals\n  | ShiftLeftEquals\n  | ShiftRightEquals\n  | BitAnd\n  | BitOr\n  | BitNegate\n  | BitShiftLeft\n  | BitShiftRight\n  | BitUnsignedShiftRight\n  | SmallerEqualThan\n  | LargerEqualThan\n  | SmallerThan\n  | LargerThan\n  | StrictNotEqual\n  | NotEqual\n  | StrictEqual\n  | Equal\n  | Plus\n  | Minus\n  | Divide\n  | Power\n  | Multiply\n  | Modulus\n  | Block\n  | Expression\n  | Return\n  | Throw\n  | Switch\n  | SwitchCase\n  | Var\n  | Let\n  | Const\n  | Number\n  | BigInt\n  | GlobalSymbol\n  | LiteralIndex\n  | StringIndex\n  | RegexIndex\n  | Function\n  | InlineFunction\n  | ArrowFunction\n  | Loop\n  | LoopAction\n  | Try\n  | Void\n  | Await\n  | New\n  | None;\n\nexport interface IRegEx {\n  regex: string;\n  flags: string;\n  length: number;\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[];\n  constants: IConstants;\n}\n\ntype LispCallback<T> = (\n  strings: IConstants,\n  type: T,\n  part: CodeString,\n  res: string[],\n  expect: string,\n  ctx: { lispTree: Lisp }\n) => any;\nconst lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + ': ' + code.substring(0, 40));\n  }\n}\n\nlet lastType: CodeString | string;\nlet lastPart: CodeString | string;\nlet lastLastPart: CodeString | string;\nlet lastLastLastPart: CodeString | string;\nlet lastLastLastLastPart: CodeString | string;\n\nconst inlineIfElse = /^:/;\nconst elseIf = /^else(?![\\w$])/;\nconst ifElse = /^if(?![\\w$])/;\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|%)(?!=)/,\n      op: /^(\\+(?!(\\+))|-(?!(-)))(?!=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w$])|in(?![\\w$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: ['expEnd'],\n  },\n  assignment: {\n    types: {\n      assignModify: /^(-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  incrementerBefore: {\n    types: { incrementerBefore: /^(\\+\\+|--)/ },\n    next: ['prop'],\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[(]/,\n      incrementerAfter: /^(\\+\\+|--)/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^-(?!-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w$])/,\n      delete: /^delete(?![\\w$])/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z$_])/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z$_][a-zA-Z\\d$_]*/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number:\n        /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[+-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w$])/,\n      boolean: /^(true|false)(?![\\w$])/,\n      null: /^null(?![\\w$])/,\n      und: /^undefined(?![\\w$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*=>\\s*({)?/,\n      arrowFunction:\n        /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w$])/,\n      Infinity: /^Infinity(?![\\w$])/,\n      void: /^void(?![\\w$])\\s*/,\n      await: /^await(?![\\w$])\\s*/,\n      new: /^new(?![\\w$])\\s*/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*(=)?/,\n      return: /^return(?![\\w$])/,\n      throw: /^throw(?![\\w$])\\s*/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore', 'expEnd'],\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  expEnd: { types: {}, next: [] },\n  expFunction: {\n    types: {\n      function:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: ['expEdge', 'expEnd'],\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*do(?![\\w$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w$])\\s*([a-zA-Z$_][\\w$]*)?/,\n      if: /^((([a-zA-Z$_][\\w$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: ['expEnd'],\n  },\n} as Record<string, { types: Record<string, RegExp>; next: string[] }>;\n\nconst closings = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  \"'\": \"'\",\n  '\"': '\"',\n  '`': '`',\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray | null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst emptyString = new CodeString('');\n\nconst okFirstChars = /^[+\\-~ !]/;\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w$])|[\\w$]+)/;\nconst semiColon = /^;/;\nconst insertedSemicolons: WeakMap<{ str: string }, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{ str: string }, Map<number, number>> = new WeakMap();\nexport interface restDetails {\n  oneliner?: boolean;\n  words?: string[];\n  lastWord?: string;\n  lastAnyWord?: string;\n  regRes?: RegExpExecArray;\n}\nexport function restOfExp(\n  constants: IConstants,\n  part: CodeString,\n  tests?: RegExp[],\n  quote?: string,\n  firstOpening?: string,\n  closingsTests?: RegExp[],\n  details: restDetails = {}\n): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = '';\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === '`') {\n      if (quote === '`' && char === '$' && part.char(i + 1) === '{' && !escape) {\n        const skip = restOfExp(constants, part.substring(i + 2), [], '{');\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === '\\\\';\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true;\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === '{') {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        const skip = restOfExp(constants, part.substring(i + 1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          const sub = part.substring(i);\n          let found: RegExpExecArray | null;\n          if ((found = testMultiple(sub.toString(), closingsTests))) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray | null;\n      let foundNumber: RegExpExecArray | null;\n      if (closingsTests) {\n        let found: RegExpExecArray | null;\n        if ((found = testMultiple(sub, closingsTests))) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if ((foundNumber = aNumber.exec(sub))) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string] | RegExpExecArray | null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [';'];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true;\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if (foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if (char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = ['splitter', 'expEnd', 'inlineIf'];\n\nconst startingExecpted = [\n  'initialize',\n  'expSingle',\n  'expFunction',\n  'value',\n  'modifier',\n  'prop',\n  'incrementerBefore',\n  'expEnd',\n];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  });\n};\n\nconst closingsCreate: { [type: string]: RegExp } = {\n  createArray: /^\\]/,\n  createObject: /^\\}/,\n  group: /^\\)/,\n  arrayProp: /^\\]/,\n  call: /^\\)/,\n};\n\nconst typesCreate = {\n  createArray: LispType.CreateArray,\n  createObject: LispType.CreateObject,\n  group: LispType.Group,\n  arrayProp: LispType.ArrayProp,\n  call: LispType.Call,\n  prop: LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any;\n\nsetLispType(\n  ['createArray', 'createObject', 'group', 'arrayProp', 'call'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    let extract = emptyString;\n    const arg: CodeString[] = [];\n    let end = false;\n    let i = res[0].length;\n    const start = i;\n    while (i < part.length && !end) {\n      extract = restOfExp(constants, part.substring(i), [closingsCreate[type], /^,/]);\n      i += extract.length;\n      if (extract.trim().length) {\n        arg.push(extract);\n      }\n      if (part.char(i) !== ',') {\n        end = true;\n      } else {\n        i++;\n      }\n    }\n    const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n    let l: Lisp | Lisp[];\n\n    let funcFound: RegExpExecArray | null;\n    switch (type) {\n      case 'group':\n      case 'arrayProp':\n        l = lispifyExpr(constants, part.substring(start, i));\n        break;\n      case 'call':\n      case 'createArray':\n        // @TODO: support 'empty' values\n        l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n        break;\n      case 'createObject':\n        l = arg.map((str) => {\n          str = str.trimStart();\n          let value: Lisp;\n          let key: string | Lisp = '';\n          funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n          if (funcFound) {\n            key = funcFound[2].trimStart();\n            value = lispify(\n              constants,\n              new CodeString('function ' + str.toString().replace(key, ''))\n            );\n          } else {\n            const extract = restOfExp(constants, str, [/^:/]);\n            key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n            if (key[0] === LispType.Prop) {\n              key = (key as Prop)[2];\n            }\n            value = lispify(constants, str.substring(extract.length + 1));\n          }\n          return createLisp<KeyVal>({\n            op: LispType.KeyVal,\n            a: key,\n            b: value,\n          });\n        });\n        break;\n    }\n    const lisptype = (\n      type === 'arrayProp'\n        ? res[1]\n          ? LispType.PropOptional\n          : LispType.Prop\n        : type === 'call'\n        ? res[1]\n          ? LispType.CallOptional\n          : LispType.Call\n        : typesCreate[type]\n    ) as (typeof typesCreate)[keyof typeof typesCreate];\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(i + 1),\n      expectTypes[expect].next,\n      createLisp<\n        ArrayProp | Prop | Call | CreateObject | CreateArray | Group | PropOptional | CallOptional\n      >({\n        op: lisptype,\n        a: ctx.lispTree,\n        b: l,\n      })\n    );\n  }\n);\n\nconst modifierTypes = {\n  inverse: LispType.Inverse,\n  not: LispType.Not,\n  positive: LispType.Positive,\n  negative: LispType.Negative,\n  typeof: LispType.Typeof,\n  delete: LispType.Delete,\n} as const;\n\nsetLispType(\n  ['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<Inverse | Not | Negative | Positive | Typeof | Delete>({\n        op: modifierTypes[type],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      })\n    );\n  }\n);\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter,\n} as any;\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(2), [/^[^\\s.\\w$]/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + 2),\n    restOfExp.next,\n    createLisp<IncrementBefore | DecrementBefore>({\n      op: incrementTypes[res[0] + '$'],\n      a: lispify(constants, extract, expectTypes[expect].next),\n      b: LispType.None,\n    })\n  );\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<IncrementAfter | DecrementAfter>({\n      op: incrementTypes['$' + res[0]],\n      a: ctx.lispTree,\n      b: LispType.None,\n    })\n  );\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  instanceof: LispType.Instanceof,\n  in: LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(\n  ['assign', 'assignModify', 'boolOp'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = createLisp<\n      | And\n      | Or\n      | Instanceof\n      | In\n      | Assigns\n      | SubractEquals\n      | AddEquals\n      | DivideEquals\n      | PowerEquals\n      | MultiplyEquals\n      | ModulusEquals\n      | BitNegateEquals\n      | BitAndEquals\n      | BitOrEquals\n      | UnsignedShiftRightEquals\n      | ShiftLeftEquals\n      | ShiftRightEquals\n    >({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n);\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any;\n\nsetLispType(\n  ['opHigh', 'op', 'comparitor', 'bitwise'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const next = [expectTypes.inlineIf.types.inlineIf, inlineIfElse];\n    switch (type) {\n      case 'opHigh':\n        next.push(expectTypes.splitter.types.opHigh);\n      case 'op':\n        next.push(expectTypes.splitter.types.op);\n      case 'comparitor':\n        next.push(expectTypes.splitter.types.comparitor);\n      case 'bitwise':\n        next.push(expectTypes.splitter.types.bitwise);\n        next.push(expectTypes.splitter.types.boolOp);\n    }\n    const extract = restOfExp(constants, part.substring(res[0].length), next);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<\n        | BitAnd\n        | BitOr\n        | BitNegate\n        | BitShiftLeft\n        | BitShiftRight\n        | BitUnsignedShiftRight\n        | SmallerEqualThan\n        | LargerEqualThan\n        | SmallerThan\n        | LargerThan\n        | StrictNotEqual\n        | NotEqual\n        | StrictEqual\n        | Equal\n        | Plus\n        | Minus\n        | Divide\n        | Power\n        | Multiply\n        | Modulus\n      >({\n        op: opTypes[res[0]],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      })\n    );\n  }\n);\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  const extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while (!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse,\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++;\n    } else {\n      quoteCount--;\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree,\n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1)),\n    }),\n  });\n});\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString | undefined;\n  let first = true;\n  let elseReg: RegExpExecArray | null;\n  let details: restDetails = {};\n  while (\n    (found = restOfExp(\n      constants,\n      part.substring(found.end - part.start),\n      [elseIf, ifElse, semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details\n    )).length ||\n    first\n  ) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n\n    if (f.startsWith('if')) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if ((elseReg = /^;?\\s*else(?![\\w$])/.exec(f))) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      const ie = extractIfElse(\n        constants,\n        part.substring(found.end - part.start + (/^;?\\s*else(?![\\w$])/.exec(f)?.[0].length || 0))\n      );\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {\n    all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start),\n    true: foundTrue,\n    false: foundElse,\n  };\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], '(');\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n\n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n\n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === '{') trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === '{') elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition),\n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants),\n    }),\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], '(');\n  let start = part.toString().indexOf('{', res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError('Invalid switch');\n  let statement = insertSemicolons(\n    constants,\n    restOfExp(constants, part.substring(start + 1), [], '{')\n  );\n  let caseFound: RegExpExecArray | null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  const cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while ((caseFound = caseTest.exec(statement.toString()))) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError('Only one default switch case allowed');\n      defaultFound = true;\n    }\n    const cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = (start = caseFound[0].length + cond.length + 1);\n    const bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], '{');\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      const notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while ((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(\n      createLisp<SwitchCase>({\n        op: LispType.SwitchCase,\n        a: caseFound[1] === 'default' ? LispType.None : lispifyExpr(constants, cond),\n        b: exprs,\n      })\n    );\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases,\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    const matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length;\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(index),\n    expectTypes[expect].next,\n    createLisp<Prop | PropOptional>({\n      op: typesCreate[op],\n      a: ctx.lispTree,\n      b: prop,\n    })\n  );\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray | SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return | Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length)),\n  });\n});\n\nsetLispType(\n  ['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Number | BigInt | GlobalSymbol>({\n        op:\n          type === 'number' ? (res[10] ? LispType.BigInt : LispType.Number) : LispType.GlobalSymbol,\n        a: LispType.None,\n        b: res[10] ? res[1] : res[0],\n      })\n    );\n  }\n);\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<StringIndex | LiteralIndex | RegexIndex>({\n      op:\n        type === 'string'\n          ? LispType.StringIndex\n          : type === 'literal'\n          ? LispType.LiteralIndex\n          : LispType.RegexIndex,\n      a: LispType.None,\n      b: res[1],\n    })\n  );\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Var | Let | Const>({\n        op: lt,\n        a: res[2],\n        b: LispType.None,\n      })\n    );\n  } else {\n    ctx.lispTree = createLisp<Var | Let | Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n});\n\nsetLispType(\n  ['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const isArrow = type !== 'function' && type !== 'inlineFunction';\n    const isReturn = isArrow && !res[res.length - 1];\n    const argPos = isArrow ? 2 : 3;\n    const isAsync = res[1] ? LispType.True : LispType.None;\n    const args: string[] = res[argPos] ? res[argPos].replace(/\\s+/g, '').split(/,/g) : [];\n    if (!isArrow) {\n      args.unshift((res[2] || '').trimStart());\n    }\n    let ended = false;\n    args.forEach((arg: string) => {\n      if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n      if (arg.startsWith('...')) ended = true;\n    });\n    const f = restOfExp(\n      constants,\n      part.substring(res[0].length),\n      !isReturn ? [/^}/] : [/^[,)}\\]]/, semiColon]\n    );\n    const func = isReturn ? 'return ' + f : f.toString();\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length + func.length + 1),\n      expectTypes[expect].next,\n      createLisp<Function | InlineFunction | ArrowFunction>({\n        op: isArrow\n          ? LispType.ArrowFunction\n          : type === 'function'\n          ? LispType.Function\n          : LispType.InlineFunction,\n        a: [isAsync, ...args],\n        b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func,\n      })\n    );\n  }\n);\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s+(in|of)(?![\\w$])/;\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp | LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while': {\n      i = part.toString().indexOf('(') + 1;\n      const extract = restOfExp(constants, part.substring(i), [], '(');\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n      break;\n    }\n    case 'for': {\n      i = part.toString().indexOf('(') + 1;\n      const args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++) {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === ')') break;\n      }\n      let iterator: RegExpExecArray | null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          (getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [ofStart2, ofStart3]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$next.value'),\n            ['initialize']\n          );\n        } else {\n          (getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [inStart2, inStart3]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'),\n            ['initialize']\n          );\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError('Invalid for loop definition');\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n\n      break;\n    }\n    case 'do': {\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(\n        constants,\n        restOfExp(\n          constants,\n          part.substring(part.toString().indexOf('(', res[0].length + body.length) + 1),\n          [],\n          '('\n        )\n      );\n      break;\n    }\n  }\n  const a = [\n    checkFirst,\n    startInternal,\n    getIterator,\n    startStep,\n    step,\n    condition,\n    beforeStep,\n  ] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants),\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], '{'), constants),\n    b: LispType.None,\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None,\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\))?|finally)\\s*\\{/;\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], '{');\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = '';\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{'\n    );\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if (\n      (catchRes = catchReg.exec(part.substring(offset).toString())) &&\n      catchRes[1].startsWith('finally')\n    ) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], '{');\n    }\n  } else {\n    finallyBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{'\n    );\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b,\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length + extract.length),\n    expectTypes[expect].next,\n    createLisp<Void | Await>({\n      op: type === 'void' ? LispType.Void : LispType.Await,\n      a: lispify(constants, extract),\n      b: LispType.None,\n    })\n  );\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, '(');\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === '(') {\n    const argsString = restOfExp(constants, part.substring(i), [], '(');\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while ((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(i),\n    expectTypes.expEdge.next,\n    createLisp({\n      op: LispType.New,\n      a: lispify(constants, obj, expectTypes.initialize.next),\n      b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n    })\n  );\n});\n\nconst ofStart2 = lispify(\n  undefined as any,\n  new CodeString('let $$iterator = $$obj[Symbol.iterator]()'),\n  ['initialize']\n);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), [\n  'initialize',\n]);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), [\n  'initialize',\n]);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), [\n  'initialize',\n]);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), [\n  'initialize',\n]);\n\nfunction lispify(\n  constants: IConstants,\n  part: CodeString,\n  expected?: readonly string[],\n  lispTree?: Lisp,\n  topLevel = false\n): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError('Unexpected end of expression');\n  }\n  if (!part.length) return lispTree;\n\n  const ctx = { lispTree: lispTree };\n\n  let res: any;\n  for (const expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (const type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if ((res = expectTypes[expect].types[type].exec(str))) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch (e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  const subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    const defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) =>\n          lispify(\n            constants,\n            i ? new CodeString(defined![1] + ' ' + str) : str,\n            ['initialize'],\n            undefined,\n            true\n          )\n        ),\n        b: LispType.None,\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({ op: LispType.Expression, a: exprs, b: LispType.None });\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({\n    op: LispType.Return,\n    a: LispType.None,\n    b: lispifyExpr(constants, str),\n  });\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  const parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while (\n    (part = restOfExp(\n      constants,\n      str.substring(pos),\n      [semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details\n    )).length\n  ) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (\n      details['words']?.includes('do') &&\n      /^\\s*while(?![\\w$])/.test(str.substring(pos).toString())\n    ) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts\n    .map((str) => str.trimStart())\n    .filter((str) => str.length)\n    .map((str) => {\n      return lispifyExpr(constants, str.trimStart(), startingExecpted);\n    });\n}\n\nexport function lispifyFunction(\n  str: CodeString,\n  constants: IConstants,\n  expression = false\n): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  hoist(tree);\n  return tree;\n}\n\nfunction hoist(item: LispItem, res: Lisp[] = []): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (\n      op === LispType.Try ||\n      op === LispType.If ||\n      op === LispType.Loop ||\n      op === LispType.Switch\n    ) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({ op: LispType.Var, a: a, b: LispType.None }));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (const it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...res, ...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w$])/;\n//  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5\nconst colonsRegex = /^((([\\w$\\])\"'`]|\\+\\+|--)\\s*\\r?\\n\\s*([\\w$+\\-!~]))|(\\}\\s*[\\w$!~+\\-{(\"'`]))/;\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while (\n    (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length\n  ) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [, , a, , , b] = details.regRes;\n      edge = details.regRes[3] === '++' || details.regRes[3] === '--' ? sub.length + 1 : sub.length;\n      part = rest.substring(0, edge);\n      if (b) {\n        const res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (\n          details.lastWord === 'function' &&\n          details.regRes[5][0] === '}' &&\n          details.regRes[5].slice(-1) === '('\n        ) {\n          valid = false;\n        }\n      } else if (a) {\n        if (\n          details.lastWord === 'if' ||\n          details.lastWord === 'while' ||\n          details.lastWord === 'for' ||\n          details.lastWord === 'else'\n        ) {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = str[i] === '/' && !escape;\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  const after = str.substring(i);\n  cancel = cancel || !done || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  const flags = /^[a-z]*/.exec(after);\n  if (/^\\s+[\\w$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i - 1),\n    flags: (flags && flags[0]) || '',\n    length: i + ((flags && flags[0].length) || 0),\n  };\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/;\nconst possibleDivide = /^([\\w$\\])]|\\+\\+|--)[\\s/]/;\nexport function extractConstants(\n  constants: IConstants,\n  str: string,\n  currentEnclosure = ''\n): { str: string; length: number } {\n  let quote;\n  let extract: (string | number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx | null;\n  let comment = '';\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char = '';\n  const strRes: (string | number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray | null = null;\n  let i = 0;\n  for (i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === '*' && str[i + 1] === '/') {\n          comment = '';\n          i++;\n        } else if (comment === '\\n') {\n          comment = '';\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === '`' && char === '$' && str[i + 1] === '{') {\n          const skip = extractConstants(constants, str.substring(i + 2), '{');\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a: unraw(extract.join('')),\n              b: [],\n            });\n            li.tempJsStrings = currJs;\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join('')));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if (char === \"'\" || char === '\"' || char === '`') {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return { str: strRes.join(''), length: i };\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length - 1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === '/' && (str[i + 1] === '*' || str[i + 1] === '/')) {\n          comment = str[i + 1] === '*' ? '*' : '\\n';\n          commentStart = i;\n        } else if (\n          char === '/' &&\n          !isPossibleDivide &&\n          (regexFound = checkRegex(str.substring(i)))\n        ) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if ((isPossibleDivide = possibleDivide.exec(str.substring(i)))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === '\\\\');\n    }\n  }\n\n  if (comment) {\n    if (comment === '*') {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`);\n    }\n  }\n  return { str: strRes.join(''), length: i };\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = { strings: [], literals: [], regexes: [], eager };\n  str = extractConstants(constants, str).str;\n\n  for (const l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return { tree: lispifyFunction(new CodeString(str), constants, expression), constants };\n}\n", "import { createFunction, currentTicks } from './executor.js';\nimport parse, { lispifyFunction } from './parser.js';\nimport { IExecContext, Ticks } from './utils.js';\n\nexport interface IEvalContext {\n  sandboxFunction: typeof sandboxFunction;\n  sandboxedEval: typeof sandboxedEval;\n  sandboxedSetTimeout: typeof sandboxedSetTimeout;\n  sandboxedSetInterval: typeof sandboxedSetInterval;\n  lispifyFunction: typeof lispifyFunction;\n}\nexport type SandboxFunction = (code: string, ...args: string[]) => () => unknown;\nexport type SandboxEval = (code: string) => unknown;\nexport type SandboxSetTimeout = (\n  handler: TimerHandler,\n  timeout?: number,\n  ...args: unknown[]\n) => any;\nexport type SandboxSetInterval = (\n  handler: TimerHandler,\n  timeout?: number,\n  ...args: unknown[]\n) => any;\n\nexport function createEvalContext(): IEvalContext {\n  return {\n    sandboxFunction,\n    sandboxedEval,\n    sandboxedSetTimeout,\n    sandboxedSetInterval,\n    lispifyFunction,\n  };\n}\n\nexport function sandboxFunction(context: IExecContext, ticks?: Ticks): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: string[]) {\n    const code = params.pop() || '';\n    const parsed = parse(code);\n    return createFunction(\n      params,\n      parsed.tree,\n      ticks || currentTicks.current,\n      {\n        ...context,\n        constants: parsed.constants,\n        tree: parsed.tree,\n      },\n      undefined,\n      'anonymous'\n    );\n  }\n}\n\nexport function sandboxedEval(func: SandboxFunction): SandboxEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): SandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  };\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): SandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  };\n}\n", "import { IEvalContext } from './eval.js';\nimport { Change, ExecReturn, executeTree, executeTreeAsync } from './executor.js';\nimport {\n  createContext,\n  IContext,\n  IExecContext,\n  IGlobals,\n  IOptionParams,\n  IOptions,\n  IScope,\n  replacementCallback,\n  SandboxGlobal,\n  SubscriptionSubject,\n} from './utils.js';\n\nfunction subscribeSet(\n  obj: unknown,\n  name: string,\n  callback: (modification: Change) => void,\n  context: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  }\n): { unsubscribe: () => void } {\n  if (!(obj instanceof Object))\n    throw new Error(\n      'Invalid subscription object, got ' + (typeof obj === 'object' ? 'null' : typeof obj)\n    );\n  const names =\n    context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    },\n  };\n}\n\nexport default class SandboxExec {\n  context: IContext;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>> =\n    new WeakMap();\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>> =\n    new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptionParams, public evalContext?: IEvalContext) {\n    const opt: IOptions = Object.assign(\n      {\n        audit: false,\n        forbidFunctionCalls: false,\n        forbidFunctionCreation: false,\n        globals: SandboxExec.SAFE_GLOBALS,\n        prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES,\n        prototypeReplacements: new Map<new () => any, replacementCallback>(),\n      },\n      options || {}\n    );\n    this.context = createContext(this, opt);\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug,\n        error: console.error,\n        info: console.info,\n        log: console.log,\n        table: console.table,\n        warn: console.warn,\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp,\n    };\n  }\n\n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    const protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp,\n    ];\n    const map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(\n      Object,\n      new Set([\n        'entries',\n        'fromEntries',\n        'getOwnPropertyNames',\n        'is',\n        'keys',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'toLocaleString',\n        'toString',\n        'valueOf',\n        'values',\n      ])\n    );\n    return map;\n  }\n\n  subscribeGet(\n    callback: (obj: SubscriptionSubject, name: string) => void,\n    context: IExecContext\n  ): { unsubscribe: () => void } {\n    context.getSubscriptions.add(callback);\n    return { unsubscribe: () => context.getSubscriptions.delete(callback) };\n  }\n\n  subscribeSet(\n    obj: object,\n    name: string,\n    callback: (modification: Change) => void,\n    context: SandboxExec | IExecContext\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(\n    obj: SubscriptionSubject,\n    name: string,\n    callback: (modification: Change) => void\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: IScope[] = []): ExecReturn<T> {\n    return executeTree(\n      {\n        ticks: BigInt(0),\n      },\n      context,\n      context.tree,\n      scopes\n    );\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: IScope[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync(\n      {\n        ticks: BigInt(0),\n      },\n      context,\n      context.tree,\n      scopes\n    );\n  }\n}\n", "import { createExecContext, IExecContext, IOptionParams, IScope } from './utils.js';\nimport { createEvalContext } from './eval.js';\nimport { ExecReturn } from './executor.js';\nimport parse from './parser.js';\nimport SandboxExec from './SandboxExec.js';\n\nexport default class Sandbox extends SandboxExec {\n  constructor(options?: IOptionParams) {\n    super(options, createEvalContext());\n  }\n\n  static audit<T>(code: string, scopes: IScope[] = []): ExecReturn<T> {\n    const globals: Record<string, unknown> = {};\n    for (const i of Object.getOwnPropertyNames(globalThis) as [keyof typeof globalThis]) {\n      globals[i] = globalThis[i];\n    }\n    const sandbox = new SandboxExec({\n      globals,\n      audit: true,\n    });\n    return sandbox.executeTree(\n      createExecContext(sandbox, parse(code, true), createEvalContext()),\n      scopes\n    );\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  compile<T>(\n    code: string,\n    optimize = false\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => T } {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return { context, run: () => this.executeTree<T>(context, [...scopes]).result };\n    };\n    return exec;\n  }\n\n  compileAsync<T>(\n    code: string,\n    optimize = false\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => Promise<T> } {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {\n        context,\n        run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result),\n      };\n    };\n    return exec;\n  }\n\n  compileExpression<T>(\n    code: string,\n    optimize = false\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => T } {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return { context, run: () => this.executeTree<T>(context, [...scopes]).result };\n    };\n    return exec;\n  }\n\n  compileExpressionAsync<T>(\n    code: string,\n    optimize = false\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => Promise<T> } {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {\n        context,\n        run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result),\n      };\n    };\n    return exec;\n  }\n}\n", "const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n", "import { Mutex } from \"async-mutex\"\nimport { OfferModel } from \"./models\"\nimport { parseArgs } from \"util\"\n\ntype CacheEntry  = {\n    id: string\n    yes: string[]\n    no: string[]\n    args: {[id: string]: string}\n    pubkeyUnique: string\n}\n\ntype PaymentHandler = {\n    pay: (idx: 0 | 1, amount: number) => void\n    party: (partyName: string, partyAsset?: string) => ({\n        pays: (counterpartyName: string, counterpartyAsset?: string) => ({\n            amount: (amount: number, asset?: string) => void\n        })\n    })\n    release?: () => void\n}\n\ntype PerpetualAsset = string\n\ntype PerpetualCashFlow = {\n    from: [string, PerpetualAsset?]\n    to: [string, PerpetualAsset?]\n    amount: [number, PerpetualAsset?]\n}\n\ntype PerpetualState<T> = {[party: string]: T}\n\ntype PerpetualUpdate<T> = [PerpetualState<T>, PerpetualCashFlow[]]\n\nexport const evaluatePartyCollateral = async (o?: OfferModel): Promise<number> => { //promise is to avoid stackoverflow\n    if (o === undefined) {\n        return 0\n    } else {\n        return o.bet[0] + Math.max(await evaluatePartyCollateral(o.ifPartyWins), await evaluatePartyCollateral(o.ifCounterPartyWins))\n    }  \n}\n\nexport const evaluateCounterPartyCollateral = async (o?: OfferModel): Promise<number> => { //promise is to avoid stackoverflow\n    if (o === undefined) {\n        return 0\n    } else {\n        return o.bet[1] + Math.max(await evaluateCounterPartyCollateral(o.ifPartyWins), await evaluateCounterPartyCollateral(o.ifCounterPartyWins))\n    }\n}\n\nexport namespace DslErrors {\n    export class PerfectHedgeError extends Error {\n        public state: {[pubkey: string]: [number, boolean, any]}\n        public amount: number\n        public partyIdx: 0 | 1\n        public pair: [string, string]\n        constructor(msg: string, st: {[pubkey: string]: [number, boolean, any]}, amount: number, partyIdx: 0 | 1, pair: [string, string]) {\n            super(msg)\n            this.state = st\n            this.amount = amount\n            this.partyIdx = partyIdx\n            this.pair = pair\n        }\n    }\n    export class InfinityError<ST> extends Error {\n        public state: ST = undefined\n        constructor(msg: string, st: ST) {\n            super(msg)\n            this.state = st\n        }\n    }\n    export class InfinityCountError extends Error {}\n\n    export class PartyAtAdvantage extends Error {\n        public amount: number\n        public partyIdx: 0 | 1\n        public pair: [string, string]\n\n        constructor(msg: string, amount: number, partyIdx: 0 | 1, pair: [string, string]) {\n            super(msg)\n\n            this.amount = amount\n            this.partyIdx = partyIdx\n            this.pair = pair\n        }\n    }\n\n     export class OnePayPerCondition extends Error {\n        public amount: number\n        public partyIdx: 0 | 1\n        public pair: [string, string]\n        public state: {[pubkey: string]: [number, boolean, any]}\n\n        constructor(msg: string, amount: number, partyIdx: 0 | 1, pair: [string, string], state:{[pubkey: string]: [number, boolean, any]}) {\n            super(msg)\n\n            this.amount = amount\n            this.partyIdx = partyIdx\n            this.pair = pair\n            this.state = state\n        }\n    }\n\n    export class ComplexConditions extends Error {\n        public amount: number\n        public partyIdx: 0 | 1\n        public pair: [string, string]\n\n        constructor(msg: string, amount: number, partyIdx: 0 | 1, pair: [string, string]) {\n            super(msg)\n\n            this.amount = amount\n            this.partyIdx = partyIdx\n            this.pair = pair\n        }\n    }\n\n    export class SafeModeError extends Error {}\n\n    export class EmptyDslOutput extends Error {}\n\n}\n\nexport class Dsl {\n\n    private state: {[pubkey: string]: [number, boolean, any]} = {}\n\n    private template(): OfferModel {\n        const model: OfferModel = {\n            id: \"\",\n            bet: [0, 0],\n            betOn: undefined,\n            oracles: [],\n            question: \"\",\n            status: \"matching\",\n            blockchain: \"\",\n            role: \"initiator\"\n        }\n        return model\n    }\n\n    private root: OfferModel = this.template()\n    private cursor: OfferModel = this.root\n    private prev: OfferModel = undefined\n    private lastOutcome = undefined\n\n    private flag = false\n\n    private alicePayCounter = 0\n    private bobPayCounter = 0\n    private aliceTrackers: {[id: string]: number} = {}\n    private bobTrackers: {[id: string]: number} = {}\n\n    public pay(idx: 0 | 1, amount: number) {\n        //console.log(\"\" + idx + \"  \" + amount + \"  \" + JSON.stringify(this.prev))\n        //console.log(amount)\n\n        if (this.flagSameAssetSwap) {\n            throw Error(`Cannot swap same type of asset between ${this.selected[0]} and ${this.selected[1]}`)\n        }\n       \n\n        if (this.unssafeInifnityCtx) {\n            throw new Error(\"Payouts are disabled in unsafe infinity context. Specify cashflows in return instead\")\n        }\n\n        if (idx === undefined) {\n            throw new Error(\"party undefined\")\n        }\n        if (!this.protect) {\n            throw new Error(\"should not call outside of body; use `new Dsl((dsl) => handler).enumerate()`\")\n        }\n        if (this.prev === undefined || this.lastOutcome === undefined) {\n            new Error(\"cannot pay unconditionally!\")\n        }\n\n        if (amount <= 0) {\n            throw Error(\"Pay amount must be positive! found: \" + amount)\n        }\n\n        if (this.lastOutcome !== null) {\n            if (this.lastOutcome && idx === 0) {\n                if (this.prev.betOn === undefined || this.prev.betOn === true) {\n                    this.prev.betOn = true\n                } else {\n                    throw new DslErrors.PerfectHedgeError(\"Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!\", this.state, amount, idx, this.selected)\n                }\n            }\n    \n            if (!this.lastOutcome && idx === 0) {\n                if(this.prev.betOn === undefined || this.prev.betOn === false) {\n                    this.prev.betOn = false\n                } else {\n                    throw new DslErrors.PerfectHedgeError(\"Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!\", this.state, amount, idx, this.selected)\n                }\n            }\n        }\n\n        if (this.lastOutcome !== null) {\n            if (this.lastOutcome && idx === 1) {\n                if (this.prev.betOn === undefined || this.prev.betOn === false) {\n                    this.prev.betOn = false\n                } else {\n                    throw new DslErrors.PerfectHedgeError(\"Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!\", this.state, amount, idx, this.selected)\n                }\n            }\n    \n            if (!this.lastOutcome && idx === 1) {\n                if(this.prev.betOn === undefined || this.prev.betOn === true) {\n                    this.prev.betOn = true\n                } else {\n                    throw new DslErrors.PerfectHedgeError(\"Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!\", this.state, amount, idx, this.selected)\n                }\n            }\n        }\n\n        if (this.flag) {\n            throw new Error(\"one pay per condition check! and pay before checking out next condition too, please!\" + `\\nat amount = ${amount}; idx = ${idx}; pair = ${this.selected}`)\n        }\n\n        const id = this.megaMode ? this.currentPub : this.currentPub + JSON.stringify(this.currentArgs)\n        if (idx == 0) {\n            this.alicePayCounter++\n            if (!this.aliceTrackers[id]) {\n                this.aliceTrackers[id] = 0\n            }\n            this.aliceTrackers[id] += 1\n            //console.log(this.aliceTrackers)\n                \n            this.prev.bet[1] = Math.round(amount)\n        } else {\n            if (!this.bobTrackers[id]) {\n                this.bobTrackers[id] = 0\n            }\n            this.bobTrackers[id] += 1\n            this.bobPayCounter++\n            this.prev.bet[0] = Math.round(amount)\n        }\n        this.flag = true\n\n        if (idx === 0) {\n            this.collateral1 += amount\n            if (this.collateral1 > this.budgetBound1) {\n                const party = this.selected[0] ?? \"Alice\"\n                throw new Error(`exceeded budget ${this.budgetBound1} for ${party}, for outcomes:` + JSON.stringify(this.state))\n            }\n        }\n\n        if (idx === 1) {\n            this.collateral2 += amount\n            if (this.collateral2 > this.budgetBound2) {\n                const party = this.selected[1] ?? \"Bob\"\n                throw new Error(`exceeded budget ${this.budgetBound2} for ${party}, for outcomes:` + JSON.stringify(this.state))\n            }\n        }\n    \n    }\n\n    public currentPub: string = undefined\n    public currentArgs: {[id: string]: string} = undefined\n\n    private enrichAndProgress(aliceOutcome: boolean, pubkey: string, yes: string[], no: string[], args: {[id: string]: string} = {}) {\n        this.lastOutcome = aliceOutcome\n\n\n        this.flag = false\n        if (aliceOutcome === false) {\n            if (this.cursor.ifCounterPartyWins === undefined) {\n                this.cursor.ifCounterPartyWins = this.template()\n            } else {\n                const x = this.cursor.ifCounterPartyWins.bet\n                this.cursor.ifCounterPartyWins.bet = [x[0] === null ? 0 : x[0], x[0] === null ? 0 : x[0]]\n            }\n            this.prev = this.cursor\n            this.cursor = this.cursor.ifCounterPartyWins\n            \n            \n        } else if (aliceOutcome === true) {\n            if (this.cursor.ifPartyWins === undefined) {\n                this.cursor.ifPartyWins = this.template()\n            } else {\n                const x = this.cursor.ifPartyWins.bet\n                this.cursor.ifPartyWins.bet = [x[0] === null ? 0 : x[0], x[0] === null ? 0 : x[0]]\n            }\n            this.prev = this.cursor\n            this.cursor = this.cursor.ifPartyWins\n        }\n        if (this.prev) {\n            this.prev.oracles[0] = {\n                capabilityPub: pubkey.replaceAll(/-###-.*/g, \"\"),\n                params: args\n            }\n            this.prev.yesOutcomes = yes\n            this.prev.noOutcomes = no\n        }\n        \n    }\n\n    private counter = 0\n\n\n    private memoize: CacheEntry[] = []\n\n    private checked = []\n\n    public superMode = false\n\n    public safeMode = false\n\n    public megaMode = false\n\n    private safeModeStarted = false\n    private megaModeStarted = false\n    private superModeStarted = false\n    private fairModeStarted = false\n    private strictModeStarted = false\n\n    public security = {\n        startSafeMode: () => {\n            if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {\n                throw new Error('Safe mode has to be started before any payouts or observations happen!')\n            }\n            if (this.safeMode) {\n                throw new Error('Safe mode already enabled manually!')\n            }\n            this.safeModeStarted = true\n            this.safeMode = true\n\n        },\n        startMegaMode: () => {\n            if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {\n                throw new Error('Mega mode has to be started before any payouts or observations happen!')\n            }\n            if (this.megaMode) {\n                throw new Error('Mega mode already enabled manually!')\n            }\n            this.megaModeStarted = true\n            this.megaMode = true\n\n        },\n        startSuperMode: () => {\n            if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {\n                throw new Error('Super mode has to be started before any payouts or observations happen!')\n            }\n            if (this.superMode) {\n                throw new Error('Super mode already enabled manually!')\n            }\n            this.superModeStarted = true\n            this.superMode = true\n        },\n        startFairMode: () => {\n            if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {\n                throw new Error('Fair mode has to be started before any payouts or observations happen!')\n            }\n            if (this.megaMode) {\n                throw new Error('Fair mode already enabled manually!')\n            }\n            this.fairModeStarted = true\n            this.strictlyFair = true\n\n        },\n        startStrictMode: () => {\n            if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {\n                throw new Error('Strict mode has to be started before any payouts or observations happen!')\n            }\n            if (this.megaMode) {\n                throw new Error('Strict mode already enabled manually!')\n            }\n            this.strictModeStarted = true\n            this.strictlyStrict = true\n\n        },\n    }\n\n    public insecurity = {\n        open: {\n            disableSafeMode: () => {\n                if (this.safeModeStarted) {\n                    throw new Error('Safe mode has to be started with `startSafeMode`!')\n                }\n                if (!this.safeMode) {\n                    throw new Error('Safe mode has to be enabled first!')\n                }\n                this.safeMode = false\n            },\n            disableMegaMode: () => {\n                if (this.megaModeStarted) {\n                    throw new Error('Mega mode has to be started with `startMegaMode`!')\n                }\n                if (!this.megaMode) {\n                    throw new Error('Mega mode has to be enabled first!')\n                }\n                this.megaMode = false\n            },\n            disableSuperMode: () => {\n                if (this.superModeStarted) {\n                    throw new Error('Super mode has to be started with `startSuperMode`!')\n                }\n                if (!this.superMode) {\n                    throw new Error('Super mode has to be enabled first!')\n                }\n                this.superMode = false\n            }\n        },\n        close: {\n            reEnableSafeMode: () => {\n                if (this.safeModeStarted) {\n                    throw new Error('Safe mode has to be started with `startSafeMode`!')\n                }\n                if (this.safeMode) {\n                    throw new Error('Safe mode has to be disabled first!')\n                }\n                this.safeMode = false\n            },\n            reEnableMegaMode: () => {\n                if (this.megaModeStarted) {\n                    throw new Error('Mega mode has to be started with `startMegaMode`!')\n                }\n                if (this.megaMode) {\n                    throw new Error('Mega mode has to be disabled first!')\n                }\n                this.megaMode = false\n            },\n            reEnableSuperMode: () => {\n                if (this.superModeStarted) {\n                    throw new Error('Mega mode has to be started with `startSuperMode`!')\n                }\n                if (this.superMode) {\n                    throw new Error('Mega mode has to be disabled first!')\n                }\n                this.superMode = false\n            }\n        }\n    }\n\n    public strictlyOneLeafPays = false\n\n    public strictlyOneLeafPairPays = false\n\n    public flagSameAssetSwap = false\n\n    public outcome(pubkey: string, yes: string[], no: string[], args: {[id: string]: string} = {}, allowTruth = false, strict = true, ignoreObserveChecksSuperUnsafe = false): boolean {\n        this.currentPub = pubkey\n        this.currentArgs = args\n        \n        const pubkeyUnique = pubkey + \"-###-\"  + JSON.stringify(yes) + JSON.stringify(no) + JSON.stringify(args);\n        if(ignoreObserveChecksSuperUnsafe) {\n            if (this.state[pubkeyUnique] === undefined) {\n                const memoized = this.memoize.find(x => x.id === pubkey && JSON.stringify(x.yes.sort()) === JSON.stringify(yes.sort()) && JSON.stringify(x.args) === JSON.stringify(args))\n                const pubkeyUnique = pubkey + \"-###-\"  + JSON.stringify(yes) + JSON.stringify(memoized.no) + JSON.stringify(args);\n                if (!this.state[pubkeyUnique]) {\n                    throw new Error(\"Did not find memoized state \" + pubkeyUnique + \"\\n\" + this.state)\n                }\n                this.enrichAndProgress(this.state[pubkeyUnique][1], pubkeyUnique, yes, no, args)\n                return this.state[pubkeyUnique][1]\n            }\n            this.enrichAndProgress(this.state[pubkeyUnique][1], pubkeyUnique, yes, no, args)\n            return this.state[pubkeyUnique][1]\n        }\n\n        if (strict) {\n            this.alicePayCounter = 0\n            this.bobPayCounter = 0\n        }\n\n        if (allowTruth && this.selected !== undefined) {\n            const tokens1 = this.selected[0].split(\"_\")\n            const asset1 = tokens1.length === 1 ? \"btc\" : tokens1[tokens1.length - 1]\n            const tokens2 = this.selected[1].split(\"_\")\n            const asset2 = tokens2.length === 1 ? \"btc\" :tokens2[tokens2.length - 1]\n            if (asset1 === asset2) {\n                this.flagSameAssetSwap = true\n            }\n        }\n        \n        yes.sort()\n        no.sort()\n        this.counter++\n\n        if ((new Set(yes)).size !== yes.length) {\n            throw Error(\"Duplicate outcomes:\" + JSON.stringify(yes) + \"; pubkey: \" + pubkey)\n        }\n\n        if ((new Set(no)).size !== no.length) {\n            throw Error(\"Duplicate outcomes: \" + JSON.stringify(no)) + \"; pubkey: \" + pubkey\n        }\n\n        if (strict && (yes.length === 0 || no.length === 0)) {\n            throw Error(\"One of the outcome sets is empty. Trader would possibly benefit regardless of outcome. Use `dsl.unsafe` to allow!\" +  \"; pubkey: \" + pubkey)\n        }\n\n        if (yes.length === 0 && no.length === 0) {\n            throw Error(\"Transaction race! Outcomes are empty. Trader cannot benefit regardless of outcome. Use `dsl.unsafe` with synthetic outcome (convention: btc script generated outcomes should start with $, e.g. $(thisTx.utxo[0])) to allow!\" +  \"; pubkey: \" + pubkey)\n        }\n\n        if (JSON.stringify(yes) === JSON.stringify(no) && !allowTruth) {\n            throw Error(\"Contradiction! Outcomes are not mutually exclusive!\" +  \"; pubkey: \" + pubkey)\n        }\n\n        const yesSet = new Set(yes)\n        const noSet = new Set(no)\n        if (yes.find(x => noSet.has(x)) || no.find(x => yesSet.has(x))) {\n            if (strict) {\n                throw Error(\"Partial contradiction! Some outcomes are not mutually exclusive!\" +  \"; pubkey: \" + pubkey)\n            }\n        }\n\n        if (!this.protect) {\n            throw \"should not call outside of body; use `new Dsl((dsl) => handler).enumerate()`\" +  \"; pubkey: \" + pubkey\n        }\n        \n        if (this.state[pubkeyUnique] === undefined) {\n            const max = Object.values(this.state).length === 0 ? -1 : Math.max(...Object.values(this.state).map(x => x[0]))\n            this.state[pubkeyUnique] = [max + 1, null, args]\n            this.checked.push(this.state[pubkeyUnique][0])\n            this.memoize.push({\n                id: pubkey, yes, no, args, pubkeyUnique\n            })\n            throw \"uninitialized\"\n        } else {\n            this.checked.push(this.state[pubkeyUnique][0])\n            if ( this.memoize.find(x => x.id === pubkey && JSON.stringify(x.yes.sort()) === JSON.stringify(yes.sort()) && JSON.stringify(x.no.sort()) === JSON.stringify(no.sort()) && JSON.stringify(x.args) === JSON.stringify(args)) !== undefined) {\n                throw new Error(\"Cannot query same observation twice. Save it into const instead: const obs1 = outcome(...); args=\" + JSON.stringify(args) + \"; pubkey: \" + pubkey)\n            }\n            const sameQuery = this.memoize.find(x => x.id === pubkey)\n            if (strict && sameQuery && JSON.stringify(sameQuery.yes.concat(sameQuery.no).sort()) !== JSON.stringify(yes.concat(no).sort())) {\n                 throw new Error(\"Set of overall outcomes must be same, regardless of parameters! \" + sameQuery.yes.concat(sameQuery.no).sort() + \" != \" + yes.concat(no).sort() +  \"; pubkey: \" + pubkey)\n            }\n\n            if (this.superMode && sameQuery && JSON.stringify(sameQuery.args) === JSON.stringify(sameQuery.args)) {\n                throw new Error(\"Cannot query same observation twice! Super strictly! Arguments are allowed to vary\" +  \"; pubkey: \" + pubkey)\n            }\n\n            if (this.megaMode && sameQuery) {\n                throw new Error(\"Cannot query same observation twice! MEGA strictly!\")\n            }\n\n            const contradiction = this.memoize.find(x => x.id === pubkey && JSON.stringify(x.yes.sort()) === JSON.stringify(no.sort()) && JSON.stringify(x.no.sort()) === JSON.stringify(yes.sort()) && JSON.stringify(x.args) === JSON.stringify(args))\n            if (contradiction !== undefined) {\n                throw new Error(\"Cannot query the opposite of checked observation. Save it into const and inverse instead: const obs1 = outcome(...); const obs2 = !obs1\" + \"; pubkey: \" + pubkey)\n            }\n            this.enrichAndProgress(this.state[pubkeyUnique][1], pubkeyUnique, yes, no, args)\n            this.memoize.push({\n                id: pubkey, yes, no, args, pubkeyUnique\n            })\n            return this.state[pubkeyUnique][1]\n        }  \n    }\n\n    private next(): boolean {\n        this.cursor = this.root\n        this.prev = undefined\n        let i = 0\n        let cursor = true\n        let entry: [number, Boolean, any] = undefined\n\n        \n        while (cursor) {\n\n            if (Object.values(this.state).find(x => x[0] === i) === undefined) {\n                return false\n            }\n            entry = Object.values(this.state).find(x => x[0] === i)\n\n            if (entry[1] === null && cursor) {\n                entry[1] = false\n                return true\n            }\n            if (!cursor) {\n                return true\n            }\n            if (entry[1] === true) {\n                if (cursor === true) {\n                    entry[1] = false\n                }\n            } else {\n                entry[1] = true\n                cursor = false \n            }\n            i++\n        }\n        return true\n    }\n\n    private body: (dsl: Dsl) => Promise<void>\n\n    public constructor(body: (dsl: Dsl) => Promise<void>) {\n        this.body = body\n    }\n\n    private protect = false\n\n    static readonly Party = 0\n    static readonly CounterParty = 1\n\n    static readonly Alice = 0\n    static readonly Bob = 1\n\n    private collateral1 = 0\n    private collateral2 = 0\n    private budgetBound1 = 0\n    private budgetBound2 = 0\n\n    private leafsFiltered = false\n\n    public strictlyStrict = false\n\n    private filterLeafs(model: OfferModel, assertNoZeros = false): OfferModel {\n        if (model === undefined) {\n            throw new DslErrors.EmptyDslOutput(\"Empty DSL model output!\")\n        }\n        if (!model.bet[0] && !model.bet[1] && !model.ifPartyWins && !model.ifCounterPartyWins) {\n            this.leafsFiltered = true\n\n            return undefined\n        }\n        if (this.strictlyFair) {\n            if (!model.bet[0] && model.bet[1]) {\n                throw new DslErrors.PartyAtAdvantage(\"Party at advantage - no premium/discount introduced\", model.bet[1], 0, this.selected)\n            }\n\n            if (model.bet[0] && !model.bet[1]) {\n                throw new DslErrors.PartyAtAdvantage(\"Party at advantage - no premium/discount introduced\", model.bet[0], 1, this.selected)\n            }\n        }\n\n        if (assertNoZeros) {\n            if (!model.bet[0] && !model.bet[1]) {\n                throw new DslErrors.ComplexConditions(\"Strict Semantics of observation: complex conditions are disallowed!\", model.bet[0], 1, this.selected)\n            }\n        }\n\n        if (model.ifPartyWins) {\n            model.ifPartyWins = this.filterLeafs(model.ifPartyWins)\n        }\n        \n        if (model.ifCounterPartyWins) {\n            model.ifCounterPartyWins = this.filterLeafs(model.ifCounterPartyWins)\n        }\n        \n        if (!model.ifPartyWins){\n            delete model.ifPartyWins\n        }\n\n        if (!model.ifCounterPartyWins){\n            delete model.ifCounterPartyWins\n        }\n\n        return model\n    }\n\n    private multiparty: string[] = []\n    private selected: [string, string] = [undefined, undefined]\n\n    private isSelected0 = (party: string) => {\n        return this.selected[0] && this.selected[0] === party \n    }\n\n    private isSelected1 = (party: string) => {\n        return this.selected[0] && this.selected[1] === party \n    }\n\n    public multiple = (...parties: string[]) => {\n        if (this.multiparty.length > 0){\n            throw Error(\"parties can be specified only once! Adding more parties ad-hoc is equivalent to early termination since consensus is required for that! \\n It is advised to create a new contract. \\n Note: you can freely parametrize Discreet contracts (terms) and use factories to easily spawn contracts with additional parties.\")\n        }\n        if (parties.length < 2) {\n            throw Error(\"Commmon sense! Minimum of 2 parties required for a contract!\")\n        }\n        const set = [...new Set(parties)]\n        if (set.length < parties.length) {\n            throw Error(\"Tractable relations! parties have to be unique!\")\n        }\n        this.multiparty = parties\n        return this\n    }\n\n    public party = (partyName: string, partyAsset?: string) => ({\n        pays: (counterpartyName: string, counterpartyAsset?: string) => ({\n            amount: (amount: number, asset?: string) => {\n                if (partyName === undefined) {\n                    throw Error(\"Party undefined\")\n                }\n                if (counterpartyName === undefined) {\n                    throw Error(\"Counter-party undefined\")\n                }\n                const party = partyName + (partyAsset ? \"_\" + partyAsset : \"\")\n                const counterparty = counterpartyName + (counterpartyAsset ? \"_\" + counterpartyAsset : \"\")\n                if  (partyAsset !== asset) {\n                    throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`)\n                }\n\n                if (!this.multiparty.find(x => x === party)){\n                    throw Error(\"party \" + party + \" not registered! Use .multiple to register parties\")\n                }\n                if (!this.multiparty.find(x => x === counterparty)){\n                    throw Error(\"counterparty \" + counterparty + \" not registered! Use .multiple to register parties\")\n                }\n                if (this.isSelected0(party) && this.isSelected1(counterparty)) {\n                    this.pay(0, amount)\n                } else if (this.isSelected0(counterparty) && this.isSelected1(party)) {\n                    this.pay(1, amount)\n                }\n            }   \n        }) \n    })\n\n    public static account(partyName: string, partyAsset: string) {\n        return partyName + \"_\" + partyAsset\n    }\n\n    public static mutual(...parties: string[]) {\n        return parties.join(\"+\")\n    }\n\n    public static refund(party: string) {\n        return party + \"_refund\"\n    }\n\n    private unfinalized = 0\n\n\n    private static track: {[id: string]: number} = {}\n\n    public static recurse = {\n        bounded: <U>(fn: () => U) => ({\n            attempts: (attempts: number) => ({\n                otherwiseYield: (defaultValue: U): (() => U) => {\n                    if (!this.track[fn.toString()]) {\n                        this.track[fn.toString()] = 0\n                    }\n                \n                    return () => {\n                        this.track[fn.toString()] = this.track[fn.toString()] + 1\n                        if (this.track[fn.toString()] > attempts) {\n                            return defaultValue\n                        }\n                        return fn()\n                    }\n\n                }\n            }) \n        })    \n    }\n\n    public strictlyFair = false\n\n    private unssafeInifnityCtx = false\n\n    public atomicSwap = {\n        ifTruth: (lock: string = \"TRUTH\", unlockOutcome: string = \"true\", args: {[id: string]: string} = {}, allowMisplacedPay = true) => {\n            return this.if(lock, [unlockOutcome], [unlockOutcome], args, true, allowMisplacedPay, false)\n        },\n        truth: (lock: string = \"TRUTH\", unlockOutcome: string = \"true\", args: {[id: string]: string} = {}) => {\n            return this.outcome(lock, [unlockOutcome], [unlockOutcome], args, true)\n        },\n    }\n\n    public unsafe = {\n        if: (pubkey: string, yes: string[], no: string[], args: {[id: string]: string} = {}, allowSwaps: boolean = false, allowMisplacedPay = true, strict = false, ignoreObserveChecksSuperUnsafe = false) => {\n            if (this.safeMode) {\n                throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n            }\n            return this.if(pubkey, yes, no, args, allowSwaps, allowMisplacedPay, strict, ignoreObserveChecksSuperUnsafe)\n        },\n        numeric: {\n            outcome: (pubkey: string, from: number, to: number, step: number = 1, args: {[id: string]: string} = {}, allowMisplacedPay = true, allowUnsafe = true, ignoreObserveChecksSuperUnsafe = false) => {\n                if (this.safeMode) {\n                    throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                }\n                return this.numeric.outcome(pubkey, from, to, step, args, allowMisplacedPay, allowUnsafe, ignoreObserveChecksSuperUnsafe)\n            },\n            infinity: {\n                bounded: (maxInfinity = 10000000, maxCount = 1000000000) => ({\n                    progress: (start: number, forward: (x: number) => number = x => x + 1) => ({\n                        perpetual: <T>(init: PerpetualState<T>, step: (x: number, st: PerpetualState<T>) => PerpetualUpdate<T>) => {\n                            if (this.safeMode) {\n                                throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                            }\n                            this.unsafe.infinity\n                            .bounded(maxInfinity, maxCount)\n                            .compare((a,b) => a - b)\n                            .progress(start, forward)\n                            .perpetual(init, step)\n                        }\n                    }),\n                    perpetual: <T>(init: PerpetualState<T>, step: (x: number, st: PerpetualState<T>) => PerpetualUpdate<T>) => {\n                        if (this.safeMode) {\n                            throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                         }\n                        this.unsafe.infinity\n                        .bounded(maxInfinity, maxCount)\n                        .compare((a,b) => b - a)\n                        .progress(0, x => x + 1)\n                        .perpetual(init, step)\n                    }\n                })\n            },\n        },\n        set: {\n            outcome: (pubkey: string, set:string[], args: {[id: string]: string} = {}, allowMisplacedPay = true, allowUnsafe = true) => {\n                if (this.safeMode) {\n                    throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                }\n                return this.set.outcome(pubkey, set, args, allowMisplacedPay, allowUnsafe)\n            },\n            outcomeT: <T>(pubkey: string, set:T[], renderer: (x: T) => string, args: {[id: string]: string} = {},  allowMisplacedPay = true, allowUnsafe = true) => {\n                if (this.safeMode) {\n                    throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                }\n                return this.set.outcomeT(pubkey, set, renderer, args, allowMisplacedPay, allowUnsafe)\n            }\n        },\n        outcome: (pubkey: string, yes: string[], no: string[], args: {[id: string]: string} = {}, allowTruth = false, strict = false, ignoreObserveChecksSuperUnsafe = false) => {\n            if (this.safeMode) {\n                throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n            }\n            return this.outcome(pubkey, yes, no, args, allowTruth, strict, ignoreObserveChecksSuperUnsafe)\n        },\n        infinity: {\n            move: <T>(x: T) => {\n                if (x === undefined) {\n                    throw new Error(\"Cannot move with undefined state!\")\n                }\n                return x\n            },\n            stop:  <T>(cashflows: T): [any, T] => [undefined, cashflows],\n            bounded: <T>(maxInfinity: T, maxCount = 10000) => ({\n                compare: (cmp: (a: T, b: T) => number) => ({\n                    progress: (start: T, forward: (x: T) => T) => ({\n                        perpetual: <ST>(init: PerpetualState<ST>, step: (x: T, st: PerpetualState<ST>) => PerpetualUpdate<ST>) => {\n                            if (this.safeMode) {\n                                throw new DslErrors.SafeModeError(\"safe mode is activated! unsafe is disallowed!\")\n                            }\n                            let cursor = start\n                            let counter = 0\n                            let state = init\n                            this.unssafeInifnityCtx = true\n                            try {\n                                while (cmp(cursor, maxInfinity) > 0 && counter < maxCount) {\n                                    const saveState = state;\n                                    let cashflows: PerpetualCashFlow[] = undefined;\n                                    \n                                    [state, cashflows] = step(cursor, state)\n\n                                    cashflows.forEach(cashflow => {\n                                        try {\n                                            this.party(\n                                                cashflow.from[0], \n                                                cashflow.from[1]\n                                            ).pays(\n                                                cashflow.to[0],\n                                                cashflow.to[1]\n                                            ).amount(\n                                                cashflow.amount[0],\n                                                cashflow.amount[1]\n                                            )\n                                        } catch (e) {\n                                            if (e instanceof DslErrors.PerfectHedgeError) {\n                                                const party = e.pair[e.partyIdx]\n                                                state[party] = saveState[party] //repair\n                                            }\n                                        }\n                                    })\n                                    \n                                    if (state === undefined){\n                                        return\n                                    }\n                                    if (state === saveState) {\n                                        throw new DslErrors.InfinityError(\"Infinity Inferred! State did not progress! Collaterals are not decreasing?\", state)\n                                    }\n                                    cursor = forward(cursor)\n                                    counter++\n                                }\n                                if (counter >= maxCount) {\n                                    throw new DslErrors.InfinityCountError(\"Max count reached!\")\n                                }\n                                if (cmp(cursor, maxInfinity) <= 0) {\n                                    throw new DslErrors.InfinityError(\"Infinity Reached! Collaterals are not decreasing?\", state)\n                                }\n                            } finally {\n                                this.unssafeInifnityCtx = false\n                            }\n                        }\n                    })\n                })\n            })\n        }\n\n    }\n\n     public infinity = {\n        move: <T>(x: T) => {\n            if (x === undefined) {\n                throw new Error(\"Cannot move with undefined state!\")\n            }\n            return x\n        },\n        stop: undefined,\n        bounded: <T>(maxInfinity: T, maxCount = 10000) => ({\n            compare: (cmp: (a: T, b: T) => number) => ({\n                progress: (start: T, forward: (x: T) => T) => ({\n                    perpetual: <ST>(init: ST, step: (x: T, st: ST) => ST) => {\n                        let cursor = start\n                        let counter = 0\n                        let state = init\n                        while (cmp(cursor, maxInfinity) > 0 && counter < maxCount) {\n                            const saveState = state\n                            state = step(cursor, state)\n                            if (state === undefined){\n                                return\n                            }\n                            if (state === saveState) {\n                                throw new DslErrors.InfinityError(\"Infinity Inferred! State did not progress! Collaterals are not decreasing?\", state)\n                            }\n                            cursor = forward(cursor)\n                            counter++\n                        }\n                        if (counter >= maxCount) {\n                            throw new DslErrors.InfinityCountError(\"Max count reached!\")\n                        }\n                        if (cmp(cursor, maxInfinity) <= 0) {\n                            throw new DslErrors.InfinityError(\"Infinity Reached! Collaterals are not decreasing?\", state)\n                        }\n                    }\n                })\n            })\n        })\n    }\n\n    public bool = {\n        safe: {\n            outcome: (pubkey: string, yes: string, no: string, args: {[id: string]: string} = {}): boolean => {\n                return this.outcome(pubkey, [yes], [no], args)      \n            }\n        },\n    }\n\n    public numeric = {\n        infinity: {\n            bounded: (maxInfinity = 10000000, maxCount = 1000000000) => ({\n                progress: (start: number, forward: (x: number) => number = x => x + 1) => ({\n                    perpetual: <T>(init: T, step: (x: number, st: T) => T) => {\n                        this.infinity\n                        .bounded(maxInfinity, maxCount)\n                        .compare((a,b) => a - b)\n                        .progress(start, forward)\n                        .perpetual(init, step)\n                    }\n                }),\n                perpetual: <T>(init: T, step: (x: number, st: T) => T) => {\n                    this.infinity\n                    .bounded(maxInfinity, maxCount)\n                    .compare((a,b) => b - a)\n                    .progress(0, x => x + 1)\n                    .perpetual(init, step)\n                }\n            })\n        },\n        safe: {\n            outcome: (pubkey: string, yes: number, no: number, args: {[id: string]: string} = {}): number => {\n                if (this.outcome(pubkey, [`${yes}`], [`${no}`], args)) {\n                    return yes\n                } else {\n                    return no\n                }\n            },\n            if: (pubkey: string, yes: number, no: number, args: {[id: string]: string} = {}, allowSwaps = false, allowMisplacedPay = false, strict = true) => {\n                const iff = this.if(pubkey, [`${yes}`], [`${no}`], args, allowSwaps, allowMisplacedPay, strict)\n                return {\n                    then: (handler: (v: number, p: PaymentHandler) => void) => {\n                        const thenn = iff.then(h => handler(yes, h))\n                        return {\n                            else: (handler: (v: number, p: PaymentHandler) => void) => {\n                                return thenn.else(h => handler(no, h))\n                            }\n                        }\n                    }\n                }\n            }\n\n        },\n        outcome: (pubkey: string, from: number, to: number, step: number = 1, args: {[id: string]: string} = {}, allowMisplacedPay = false, allowUnsafe = false, ignoreObserveChecksSuperUnsafe = false) => ({\n            evaluate: (handler: (n: number) => void) => {\n                let numbers = []\n                for (let i = from; i <= to; i += step) {\n                    numbers.push(i)\n                }\n\n                const recurse = (l: number[], r: number[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    if (this.outcome(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, false)) {\n                        if (l.length === 1) {\n                            if (this.outcome(pubkey, l.map(x => x.toString()), [], args, false, false, true)) {\n                                handler(l[0])\n                            }\n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            handler(r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n                recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2))\n\n                const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                if (!allowUnsafe) {\n                    \n                    if (this.aliceTrackers[id] > numbers.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                    }\n                    if (this.bobTrackers[id] > numbers.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                    }\n                }\n\n                if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.OnePayPerCondition(\"Only one leaf in a tree is alowed to pay\", undefined, undefined, this.selected, this.state)\n                }\n\n                if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.PerfectHedgeError(\"Only one pair in a tree is alowed to pay\", this.state, undefined, undefined, this.selected)\n                }\n                \n            },\n            evaluateWithPaymentCtx: (payhandler: (h: PaymentHandler, n: number) => void) => {\n                let numbers = []\n                for (let i = from; i <= to; i += step) {\n                    numbers.push(i)\n                }\n                 const recurse = (l: number[], r: number[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    this.unsafe.if (pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n\n                            this.unsafe.if (pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, false, true).then(h => {\n                                payhandler(h, l[0])\n                            })\n                            \n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            \n                            payhandler(h, l[0])\n                            \n                        } else {\n                            \n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                            \n                        }\n                    })\n                }\n\n                recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2))\n\n                const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                if (!allowUnsafe) {\n                    if (this.aliceTrackers[id] > numbers.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                    }\n                    if (this.bobTrackers[id] > numbers.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                    }\n                }\n   \n            },\n            value: (): number => {\n                let numbers: number[] = []\n                for (let i = from; i <= to; i += step) {\n                    numbers.push(i)\n                }\n               const recurse = (l: number[], r: number[]) => {\n                    if (l.length === 1 && r.length === 0) {\n                        return l[0]\n                    }\n                    if (r.length === 1 && l.length === 0) {\n                        return r[0]\n                    }\n                    if (this.unsafe.outcome(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args)) {\n                        if (l.length === 1) {\n                            if (this.unsafe.outcome(pubkey, l.map(x => x.toString()), [], args, false, false, true)){\n                                return l[0]\n                            } else {\n                                throw \"skip\"\n                            }    \n                        } else {\n                            return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            return r[0]\n                        } else {\n                            return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n                if (!allowUnsafe) {\n                    throw new Error('Only available in unsafe mode')\n                }\n\n                return recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2))\n            }, \n            valueWithPaymentCtxUnsafe: (): [number, PaymentHandler] => {\n                let numbers = []\n                for (let i = from; i <= to; i += step) {\n                    numbers.push(i)\n                }\n\n                let nn = numbers[0]\n                let hh = undefined\n                let payhandler = (h: PaymentHandler, n: number) => {\n                    nn = n\n                    hh = h\n                }\n\n                let argument = args\n                \n                const recurse = (l: number[], r: number[], payhandlerOut: PaymentHandler) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    this.unsafe.if(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), argument, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n                            this.unsafe.if (pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, false, true).then(h => {\n                                payhandler(h, l[0])\n                            }).else(_ => {\n                                throw \"skip\"\n                            })                           \n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2), h)\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            payhandler(h, r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2), h)\n                        }\n                    })\n                }\n\n                recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2), null)\n                this.unfinalized++\n\n                const saveRelease = hh.release\n                hh.release = () => {\n                    const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                    if (!allowUnsafe) {\n                        if (this.aliceTrackers[id] > numbers.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                        }\n                        if (this.bobTrackers[id] > numbers.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                        }\n                    }\n                    saveRelease()\n                }\n\n                if (hh === undefined) {\n                    this.unfinalized--\n                    throw \"skip\"\n                }\n                \n                return [nn, hh]\n            }\n        })\n    }\n\n    public set = {\n        safe: {\n            outcome: (pubkey: string, yes: string, no: string, args: {[id: string]: string} = {}, allowMisplacedPay = false): string => {\n                if (this.outcome(pubkey, [yes], [no], args)) {\n                    return yes\n                } else {\n                    return no\n                }\n            },\n            outcomeT: <T1, T2>(pubkey: string, yes: T1, no: T2, renderer: (x: T1 | T2) => string = x => x.toString(), args: {[id: string]: string} = {}): T1 | T2 => {\n                if (this.outcome(pubkey, [renderer(yes)], [renderer(no)], args)) {\n                    return yes\n                } else {\n                    return no\n                }\n            },\n            if: (pubkey: string, yes: string, no: string, args: {[id: string]: string} = {}) => {\n                const iff = this.if(pubkey, [yes], [no], args)\n                return {\n                    then: (handler: (v: string, p: PaymentHandler) => void) => {\n                        const thenn = iff.then(h => handler(yes, h))\n                        return {\n                            else: (handler: (v: string, p: PaymentHandler) => void) => {\n                                return thenn.else(h => handler(no, h))\n                            }\n                        }\n                    }\n                }\n            },\n            ifT: <T1, T2>(pubkey: string, yes: T1, no: T2, renderer: (x: T1 | T2) => string = x => x.toString(), args: {[id: string]: string} = {}) => {\n                const iff = this.if(pubkey, [renderer(yes)], [renderer(no)], args)\n                return {\n                    then: (handler: (v: T1, p: PaymentHandler) => void) => {\n                        const thenn = iff.then(h => handler(yes, h))\n                        return {\n                            else: (handler: (v: T2, p: PaymentHandler) => void) => {\n                                return thenn.else(h => handler(no, h))\n                            }\n                        }\n                    }\n                }\n            }\n\n        },\n        outcome: (pubkey: string, set:string[], args: {[id: string]: string} = {}, allowMisplacedPay = false, allowUnsafe = true) => ({\n            evaluate: (handler: (n: string) => void) => {\n                const recurse = (l: string[], r: string[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    if (this.unsafe.outcome(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args)) {\n                        if (l.length === 1) {\n                            if (this.unsafe.outcome(pubkey, l, [], args, false, true, true)) {\n                                handler(l[0])\n                            }\n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            handler(r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n\n                const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                if (!allowUnsafe) {\n                    if (this.aliceTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                    }\n                    if (this.bobTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                    }\n                }\n\n                if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.OnePayPerCondition(\"Only one leaf in a tree is alowed to pay\", undefined, undefined, this.selected, this.state)\n                }\n\n                if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.PerfectHedgeError(\"Only one pair in a tree is alowed to pay\", this.state, undefined, undefined, this.selected)\n                }\n\n                \n            },\n            evaluateWithPaymentCtx: (payhandler: (h: PaymentHandler, n: string) => void) => {\n\n                 const recurse = (l: string[], r: string[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    this.if (pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n                            this.if(pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, false, true).then(h => {\n                                payhandler(h, l[0])\n                            })                        \n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            payhandler(h, r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    })\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n\n                const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                if (!allowUnsafe) {\n                    if (this.aliceTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                    }\n                    if (this.bobTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                    }\n                }\n\n            },\n            value: (): string => {\n                const recurse = (l: string[], r: string[]) => {\n                    if (l.length === 1 && r.length === 0) {\n                        return l[0]\n                    }\n                    if (r.length === 1 && l.length === 0) {\n                        return r[0]\n                    }\n                    if (this.outcome(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args)) {\n                        if (l.length === 1) {\n                            if (this.outcome(pubkey, l.map(x => x.toString()), [], args, false, false, true)) {\n                                return l[0]\n                            } else {\n                                throw \"skip\"\n                            }\n                        } else {\n                            return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            return r[0]\n                        } else {\n                            return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                return recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n            },\n            valueWithPaymentCtxUnsafe: (): [string, PaymentHandler] => {\n                let nn = set[0]\n                let hh = undefined\n\n                const payhandler = (h: PaymentHandler, n: string) => {\n                    nn = n\n                    hh = h\n                }\n                \n                const recurse = (l: string[], r: string[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    this.if(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n                            this.if(pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, true).then(h => {\n                                payhandler(h, l[0])\n                            })\n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            payhandler(h, r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    })\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n                this.unfinalized++\n\n                const saveRelease = hh.release\n                hh.release = () => {\n                    const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                    if (!allowUnsafe) {\n                        if (this.aliceTrackers[id] > set.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                        }\n                        if (this.bobTrackers[id] > set.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                        }\n                    }\n                    saveRelease()\n                }\n\n                if (hh === undefined) {\n                    this.unfinalized--\n                    throw \"skip\"\n                }\n\n                return [nn, hh]\n            }\n        }),\n        outcomeT: <T>(pubkey: string, set:T[], renderer: (x: T) => string, args: {[id: string]: string} = {},  allowMisplacedPay = false, allowUnsafe = false) => ({\n            evaluate: (handler: (n: T) => void) => {\n                 const recurse = (l: T[], r: T[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    if (this.unsafe.outcome(pubkey, l.map(x => renderer(x)), r.map(x => renderer(x)), args)) {\n                        if (l.length === 1) {\n                            if (this.unsafe.outcome(pubkey, l.map(x => renderer(x)), [], args, false, false, true)) {\n                                handler(l[0])\n                            }\n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            handler(r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n\n                const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                if (!allowUnsafe) {\n                    if (this.aliceTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                    }\n                    if (this.bobTrackers[id] > set.length - 1) {\n                        throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                    }\n                }\n\n                if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.OnePayPerCondition(\"Only one leaf in a tree is alowed to pay\", undefined, undefined, this.selected, this.state)\n                }\n\n                if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {\n                    throw new DslErrors.PerfectHedgeError(\"Only one pair in a tree is alowed to pay\", this.state, undefined, undefined, this.selected)\n                }\n                \n            },\n            evaluateWithPaymentCtx: (payhandler: (h: PaymentHandler, n: T) => void) => {\n                const recurse = (l: T[], r: T[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    this.if (pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n                            this.if(pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, false, true).then(h => {\n                                payhandler(h, l[0])\n                            })        \n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            payhandler(h, r[0])\n                            \n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    })\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n            },\n            value: (): T => {\n                const recurse = (l: T[], r: T[]) => {\n                    if (l.length === 1 && r.length === 0) {\n                        return l[0]\n                    }\n                    if (r.length === 1 && l.length === 0) {\n                        return r[0]\n                    }\n                    if (this.outcome(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args)) {\n                        if (l.length === 1) {\n                            if (this.outcome(pubkey, l.map(x => x.toString()), [], args, false, false, true)) {\n                                return l[0]\n                            }\n                        } else {\n                            return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    } else {\n                        if (r.length === 1) {\n                            return r[0]\n                        } else {\n                            return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2))\n                        }\n                    }\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                return recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n            },\n            valueWithPaymentCtxUnsafe: (): [T, PaymentHandler] => {\n                let nn = set[0]\n                let hh: PaymentHandler = undefined\n                let payhandler = (h: PaymentHandler, n: T) => {\n                    nn = n\n                    hh = h\n                }\n                \n                const recurse = (l: T[], r: T[]) => {\n                    if (l.length === 0) {\n                        return\n                    }\n                    if (r.length === 0) {\n                        return\n                    }\n                    const rt = this.if(pubkey, l.map(x => x.toString()), r.map(x => x.toString()), args, false, allowMisplacedPay).then(h => {\n                        if (l.length === 1) {\n                            this.if(pubkey, l.map(x => x.toString()), [], args, false, allowMisplacedPay, false, true).then(h => {\n                                payhandler(h, l[0])\n                            })\n                        } else {\n                            recurse(l.slice(0, l.length / 2), l.slice(l.length / 2))\n                        }\n                    }).else(h => {\n                        if (r.length === 1) {\n                            payhandler(h, r[0])\n                        } else {\n                            recurse(r.slice(0, r.length / 2), r.slice(r.length / 2)) \n                        }\n                    })\n                }\n\n                if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {\n                    throw Error(\"Leaf strictness tracking is not available in this mode. Use `evaluate`\")\n                }\n\n                recurse(set.slice(0, set.length / 2), set.slice(set.length / 2))\n                this.unfinalized++\n\n                const saveRelease = hh.release\n                hh.release = () => {\n                    const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args)\n\n                    if (!allowUnsafe) {\n                        if (this.aliceTrackers[id] > set.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 0, this.selected)\n                        }\n                        if (this.bobTrackers[id] > set.length - 1) {\n                            throw new DslErrors.PerfectHedgeError(\"Party cannot benefit regardless of outcome\", this.state, undefined, 1, this.selected)\n                        }\n                    }\n                    saveRelease()\n                }\n\n                if (hh === undefined) {\n                    this.unfinalized--\n                    throw \"skip\"\n                }\n\n                return [nn, hh]\n            }\n            \n        })\n    }\n\n    public assert = {\n        sum: {\n            budget: (amount: number) => {\n                if (this.collateral1 + this.collateral2 > amount) {\n                    throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`)\n                }    \n            },\n            parties: (party1: string, party2: string) => ({\n                budget: (amount: number) => {\n                    if (this.isSelected0(party1) && this.isSelected1(party2)){\n                        if (this.collateral1 + this.collateral2 > amount) {\n                            throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`)\n                        }\n                    }\n                    if (this.isSelected0(party2) && this.isSelected1(party1)){\n                        if (this.collateral1 + this.collateral2 > amount) {\n                            throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`)\n                        }\n                    }\n                            \n                }\n            })\n        },\n        budget: (idx: 0, amount: number) => {\n            if (idx == 0) {\n                if (this.collateral1 > amount) {\n                    throw Error(`Max Alice budget assertion: ${this.collateral1} > ${amount}`)\n                } \n            } else {\n                if (this.collateral1 > amount) {\n                    throw Error(`Max Bob budget assertion: ${this.collateral2} > ${amount}`)\n                }\n            }\n            \n        },\n        parties: (party1: string, party2: string) => ({\n            budget: (idx: 0, amount: number) => {\n                if (this.isSelected0(party1) && this.isSelected1(party2)){\n                    if (idx == 0) {\n                        if (this.collateral1 > amount) {\n                            throw Error(`Max ${party1} budget assertion (against ${party2}): ${this.collateral1} > ${amount}`)\n                        } \n                    } else {\n                        if (this.collateral1 > amount) {\n                            throw Error(`Max ${party2} budget assertion (against ${party1}): ${this.collateral2} > ${amount}`)\n                        }\n                    }  \n                }\n                if (this.isSelected0(party2) && this.isSelected1(party1)){\n                    if (idx == 0) {\n                        if (this.collateral1 > amount) {\n                            throw Error(`Max ${party2} budget assertion (against ${party1}): ${this.collateral1} > ${amount}`)\n                        } \n                    } else {\n                        if (this.collateral1 > amount) {\n                            throw Error(`Max ${party1} budget assertion (against ${party2}): ${this.collateral2} > ${amount}`)\n                        }\n                    }  \n                }\n                          \n            }\n        })\n    }\n\n    public disablePartyRoleReversal = false\n\n    public if = (pubkey: string, yes: string[], no: string[], args: {[id: string]: string} = {}, allowSwaps: boolean = false, allowMisplacedPay = false, strict = true, ignoreObserveChecksSuperUnsafe = false) => {\n        let contradiction = false\n        const yesSet = new Set(yes)\n        const noSet = new Set(no)\n        if (yes.find(x => noSet.has(x)) || no.find(x => yesSet.has(x))) {\n            contradiction = true\n        }\n        const observation = this.outcome(pubkey, yes, no, args, allowSwaps, strict, ignoreObserveChecksSuperUnsafe)\n        const currentNode = this.cursor\n        const currentPrevNode = this.prev\n        const currentLastOutcome = this.lastOutcome\n        return {\n            then: (handler: (handle: PaymentHandler) => void) => {\n                let party: 0 | 1 = undefined\n                let sum = 0\n                const funds = {\n                    pay: (idx: 0 | 1, amount: number): void => {\n                        if (party === undefined || idx === party) {\n                            sum += amount\n                            party = idx\n                        } else {\n                            if (party !== undefined && idx !== party){\n                                if (this.disablePartyRoleReversal){\n                                    throw new Error(\"Party role reversal is disabled!\")\n                                }\n                                sum -= amount\n                            } else {\n                                throw new DslErrors.PerfectHedgeError (\"Perfect Hedge! Party cannot benefit regardless of outcome!\", this.state, amount, idx, this.selected)\n                            }  \n                        }\n                    },\n                    party: (partyName: string, partyAsset?: string) => ({\n                        pays: (counterpartyName: string, counterpartyAsset?: string) => ({\n                            amount: (amount: number, asset?: string) => {\n                                const party = partyName + (partyAsset ? \"_\" + partyAsset : \"\")\n                                const counterparty = counterpartyName + (counterpartyAsset ? \"_\" + counterpartyAsset : \"\")\n                                if (currentNode !== this.cursor && !allowMisplacedPay) {\n                                    throw Error(\"Possibly trying to pay nondeterministically! You tried to use outer account context to pay: use the closest `if(...).then/else(account => ...)` please! This also happens when you pay after checking unrelated observations: pay before checking next outcome! You can turn this off by using `dsl.unsafe`\")\n                                }\n                                if (partyAsset !== asset) {\n                                    throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`)\n                                }\n                                if (!this.multiparty.find(x => x === party)){\n                                    throw Error(\"party \" + party + \" not registered! Use .multiple to register parties\")\n                                }\n                                if (!this.multiparty.find(x => x === counterparty)){\n                                    throw Error(\"counterparty \" + counterparty + \" not registered! Use .multiple to register parties\")\n                                }\n                                if (this.isSelected0(party) && this.isSelected1(counterparty)) {\n                                    funds.pay(0, amount)\n                                } else if (this.isSelected0(counterparty) && this.isSelected1(party)) {\n                                    funds.pay(1, amount)\n                                }\n                                if (sum < 0 && partyAsset !== counterpartyAsset) {\n                                    throw new Error(`Semantics: ${partyName} cannot pay negative amount of ${partyAsset} units. It is only allowed if assets are of the same type.`)\n                                }\n                                if (contradiction && partyAsset === counterpartyAsset) {\n                                    throw Error(\"Contradiction! Outcomes are not mutually exclusive! Cannot allow swaps in same currency!\")\n                                }\n                            }   \n                        }) \n                    }),\n                    release: () => {\n                        if (currentNode !== this.cursor && !allowMisplacedPay) {\n                            throw Error(\"Trying to release nondeterministically! You tried to release using outer account context: use the closest `if(...).then/else(account => ...)` please! This also happens if you release after checking unrelated observations: release before next `outcome; use `allowMisplacedPay` in `dsl.if` to disable this check`\")\n                        }\n                        const saveCursor = this.cursor\n                        const savePrev = this.prev\n                        const saveFlag = this.flag\n                        const saveLastOutcome = this.lastOutcome\n                        if (allowMisplacedPay) {\n                            this.cursor = currentNode\n                            this.prev = currentPrevNode\n                            this.flag = false\n                            this.lastOutcome = currentLastOutcome\n                        }\n                        this.unfinalized--\n                        funds.party = undefined\n                        funds.pay = undefined\n                        if (party !== undefined && sum !== 0) {\n                            if (sum > 0) {\n                                this.pay(party, sum)\n                            } else if (sum < 0) {\n                                this.pay(party === 0 ? 1: 0, -sum)\n                            } \n                        }\n                        this.cursor = saveCursor\n                        this.prev = savePrev\n                        this.flag = saveFlag\n                        this.lastOutcome = saveLastOutcome\n                    }\n\n                }\n                const finalizeUnsafeInternal = () => {\n                    if (observation) {\n                        handler(funds)\n                        const saveCursor = this.cursor\n                        const savePrev = this.prev\n                        const saveFlag = this.flag\n                        const saveLastOutcome = this.lastOutcome\n                        if (allowMisplacedPay) {\n                            this.cursor = currentNode\n                            this.prev = currentPrevNode\n                            this.flag = false\n                            this.lastOutcome = currentLastOutcome\n                        }\n                        if (party !== undefined && sum !== 0) {\n                            if (sum > 0) {\n                                this.pay(party, sum)\n                            } else if (sum < 0) {\n                                this.pay(party === 0 ? 1: 0, -sum)\n                            } \n                        }\n                        this.cursor = saveCursor\n                        this.prev = savePrev\n                        this.flag = saveFlag\n                        this.lastOutcome = saveLastOutcome\n                    }\n                }\n                finalizeUnsafeInternal()\n                return {\n                     else: (handler: (handle: PaymentHandler) => void) => {\n                        let counterparty: 0 | 1 = undefined\n                        let sum = 0\n                        const funds = {\n                            pay: (idx: 0 | 1, amount: number): void => {\n                                if (counterparty === undefined || idx === counterparty) {\n                                    if (party !== undefined && counterparty !== undefined && party === counterparty) {\n                                        throw new DslErrors.PerfectHedgeError (\"Perfect Hedge! Party cannot benefit regardless of outcome!\", this.state, amount, idx, this.selected)\n                                    }\n                                    counterparty = idx\n                                    sum += amount\n                                } else {\n                                    if (counterparty !== undefined && idx !== counterparty){\n                                         if (this.disablePartyRoleReversal){\n                                            throw new Error(\"Party role reversal is disabled!\")\n                                        }\n                                        sum -= amount\n                                    } else {\n                                        throw new DslErrors.PerfectHedgeError (\"Perfect Hedge! Party cannot benefit regardless of outcome!\", this.state, amount, idx, this.selected)\n                                    }  \n                                }\n                            },\n                            party: (partyName: string, partyAsset?: string) => ({\n                                pays: (counterpartyName: string, counterpartyAsset?: string) => ({\n                                    amount: (amount: number, asset?: string) => {\n                                        const party = partyName + (partyAsset ? \"_\" + partyAsset : \"\")\n                                        const counterparty = counterpartyName + (counterpartyAsset ? \"_\" + counterpartyAsset : \"\")\n                                        if (currentNode !== this.cursor && !allowMisplacedPay) {\n                                            throw Error(\"Possibly trying to pay nondeterministically! You tried to use outer account context to pay: use the closest `if(...).then/else(account => ...)` please! This also happens when you pay after checking unrelated observations: pay before checking next outcome! You can turn this off by using `dsl.unsafe`\")\n                                        }\n                                        if (partyAsset !== asset) {\n                                            throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`)\n                                        }\n                                        if (!this.multiparty.find(x => x === party)){\n                                            throw Error(\"party \" + party + \" not registered! Use .multiple to register parties\")\n                                        }\n                                        if (!this.multiparty.find(x => x === counterparty)){\n                                            throw Error(\"counterparty \" + counterparty + \" not registered! Use .multiple to register parties\")\n                                        }\n                                        if (!this.multiparty.find(x => x === party)){\n                                            throw Error(\"party \" + party + \" not registered! Use .multiple to register parties in \" + this.multiparty)\n                                        }\n                                        if (!this.multiparty.find(x => x === counterparty)){\n                                            throw Error(\"counterparty \" + counterparty + \" not registered! Use .multiple to register parties in \" + this.multiparty)\n                                        }\n                                        if (this.isSelected0(party) && this.isSelected1(counterparty)) {\n                                            funds.pay(0, amount)\n                                        } else if (this.isSelected0(counterparty) && this.isSelected1(party)) {\n                                            funds.pay(1, amount)\n                                        }\n                                    }   \n                                }) \n                            }),\n                            release: () => {\n                                if (currentNode !== this.cursor && !allowMisplacedPay) {\n                                    throw Error(\"Possibly trying to release nondeterministically! You tried to release using outer account context: use the closest `if(...).then/else(account => ...)` please! This also happens if you release after checking unrelated observations: release before next `outcome`; use `allowMisplacedPay` in `dsl.if` to disable this check\")\n                                }\n                                const saveCursor = this.cursor\n                                const savePrev = this.prev\n                                const saveFlag = this.flag\n                                const saveLastOutcome = this.lastOutcome\n                                if (allowMisplacedPay) {\n                                    this.cursor = currentNode\n                                    this.prev = currentPrevNode\n                                    this.flag = false\n                                    this.lastOutcome = currentLastOutcome\n                                }\n                                this.unfinalized--\n                                funds.party = undefined\n                                funds.pay = undefined\n                                if (counterparty !== undefined && sum !== 0) {\n                                    if (sum > 0) {\n                                        this.pay(counterparty, sum)\n                                    } else if (sum < 0) {\n                                        this.pay(counterparty === 0 ? 1: 0, -sum)\n                                    } \n                                }\n                                this.cursor = saveCursor\n                                this.prev = savePrev\n                                this.flag = saveFlag\n                                this.lastOutcome = saveLastOutcome\n                            }\n                        }\n                        const finalizeUnsafeInternal2 = () => {\n                            if (!observation) {\n                                handler(funds)\n                                const saveCursor = this.cursor\n                                const savePrev = this.prev\n                                const saveFlag = this.flag\n                                const saveLastOutcome = this.lastOutcome\n                                if (allowMisplacedPay) {\n                                    this.cursor = currentNode\n                                    this.prev = currentPrevNode\n                                    this.flag = false\n                                    this.lastOutcome = currentLastOutcome\n                                }\n                                if (counterparty !== undefined && sum !== 0) {\n                                    if (sum > 0) {\n                                        this.pay(counterparty, sum)\n                                    } else if (sum < 0) {\n                                        this.pay(counterparty === 0 ? 1: 0, -sum)\n                                    }\n                                }\n                                this.cursor = saveCursor\n                                this.prev = savePrev\n                                this.flag = saveFlag\n                                this.lastOutcome = saveLastOutcome\n                            }\n                        }\n                        finalizeUnsafeInternal2()\n                        \n                    }\n                }    \n            }\n        }\n    }\n\n    public ifAtomicSwapLeg1(lock: string = \"TRUTH\", unlockOutcome: string = \"true\", allowMisplacedPay = false) {\n        return this.if(lock, [unlockOutcome], [unlockOutcome], {}, true, allowMisplacedPay)\n    }\n\n    private multiflag = false\n\n    public async enumerateWithBoundMulti(collateralBounds: [number, number][]): Promise<[string, string, OfferModel][]> {\n        this.multiflag = true\n        const pairs: [string, string][] = \n            this.multiparty.map(x => this.multiparty.map(y => [x, y] as [string, string]).filter(pair => pair[0] !== pair[1]))\n            .flat().map(x => x.sort())\n\n        const ids = new Set()\n        const uniquepairs = pairs.filter((id) => !ids.has(JSON.stringify(id)) && ids.add(JSON.stringify(id)))\n        const mutex = new Mutex()\n        const res: [string, string, OfferModel][] = await Promise.all(uniquepairs.map(async (pair, i) => { \n            return await mutex.runExclusive(async () => {\n                this.selected = pair\n                if (!collateralBounds[i]) {\n                    throw Error(\"Specify bounds for a pair \" + pair + \" at index: \" + i)\n                }\n                try {\n                    const subcontract = await this.enumerateWithBound(collateralBounds[i][0], collateralBounds[i][1])\n                return [pair[0], pair[1], subcontract]\n                } catch (e) {\n                    if (e instanceof DslErrors.EmptyDslOutput) {\n                        return [pair[0], pair[1], undefined]\n                    } else {\n                        throw e\n                    }\n                }\n                \n            })\n        }))\n        this.multiflag = false\n        return res\n    }\n\n    public async enumerateWithBound(collateralBound1: number, collateralBound2: number): Promise<OfferModel> {\n        if (this.multiparty.length > 0 && !this.multiflag){\n            throw Error(\"use `enumerateWithBoundMulti` for multiparty contracts!\")\n        }\n        if (this.protect) {\n            throw \"Don't call enumerate inside of the body of your script!\"\n        }\n        this.protect = true\n        let next = true\n        const mutex = new Mutex()\n        this.aliceTrackers = {}\n        this.bobTrackers = {}\n        while (next) {\n            try {\n                this.flagSameAssetSwap = false\n                this.collateral1 = 0\n                this.collateral2 = 0\n                this.budgetBound1 = collateralBound1\n                this.budgetBound2 = collateralBound2\n                this.memoize = []\n                this.checked = []\n                this.counter = 0\n                this.lastOutcome = undefined\n                this.flag = false\n                //console.log(\"---\" + JSON.stringify(this.state))\n                await mutex.runExclusive(async () => await this.body(this))\n                if (this.unfinalized !== 0) {\n                    throw new Error(\"\" + this.unfinalized + \" resource locks are not released! Every `[v, payments] = valueWithPaymentCtxUnsafe` must have a corresponding `payments.release()`\")\n                }\n                if (this.safeModeStarted && !this.safeMode) {\n                    throw new Error(\"All insecure safe mode escape sections must be closed! Forgot `insecure.close.reEnableMode`?\")\n                }\n                if (this.megaModeStarted && !this.megaMode) {\n                    throw new Error(\"All insecure mega mode escape sections must be closed! Forgot `insecure.close.reEnableMode`?\")\n                }\n                if (this.strictModeStarted && !this.strictlyStrict) {\n                    throw new Error(\"All insecure strict mode escape sections must be closed! Forgot `insecure.close.reEnableMode`?\")\n                }\n                if (this.superModeStarted && !this.superMode) {\n                    throw new Error(\"All insecure super mode escape sections must be closed! Forgot `insecure.close.reEnableMode`?\")\n                }\n                if (this.fairModeStarted && !this.strictlyFair) {\n                    throw new Error(\"All insecure fair mode escape sections must be closed! Forgot `insecure.close.reEnableMode`?\")\n                }\n            } catch (e) {\n                if (e === \"uninitialized\" || e === \"skip\") {\n                    //console.log(\"---\")\n                } else {\n                    throw e\n                }\n            }    \n            next = this.next()\n        }\n        this.protect = false\n\n        this.leafsFiltered = true\n        let result = this.root\n\n        while (this.leafsFiltered) {\n            this.leafsFiltered = false\n            result = this.filterLeafs(result)\n        }\n\n        if (this.strictlyStrict) {\n            this.filterLeafs(result, true)\n        }\n        return result\n    }\n}\n\nif (typeof window === 'undefined' && require.main === module) {\n    (async () => {\n        const model = await (new Dsl(async dsl => {\n            const a = 60\n            if (dsl.outcome(\"really?\", [\"YES\"], [\"NO\"])) {\n                dsl.pay(Dsl.Bob, a + 100) \n                const out1 = dsl.outcome(\"is it?\", [\"YES\"], [\"NO\", \"DON'T KNOW\"])\n                if (out1) {\n                    dsl.pay(Dsl.Alice, 40)\n                    if (dsl.outcome(\"is it?\", [\"DON'T KNOW\"], [\"NO\", \"YES\"])) {\n                        dsl.pay(Dsl.Bob, 40)\n                        dsl.if(\"lol?\", [\"yup\"], [\"nope\"]).then(funds => {\n                            funds.pay(Dsl.Bob, 20)\n                            funds.pay(Dsl.Alice, 30)\n                        }).else(funds => {\n                            funds.pay(Dsl.Bob, 40)\n                            funds.pay(Dsl.Alice, 10)\n                        })\n                    }\n                } else {\n                    dsl.pay(Dsl.Bob, 50)\n                } \n            } else {\n                dsl.pay(Dsl.Alice, 20)\n            }\n        })).multiple(\"alice\", \"bob\").enumerateWithBoundMulti([[1000, 20000]])\n        console.log(model)\n\n        const multi = await (new Dsl (async dsl => {\n            if (dsl.outcome(\"really?\", [\"YES\"], [\"NO\"])) {\n                dsl.party(\"alice\").pays(\"bob\").amount(100)\n                dsl.party(\"bob\").pays(\"carol\").amount(20)\n            } else {\n                dsl.party(\"carol\").pays(\"alice\").amount(40)\n                dsl.party(\"bob\").pays(\"alice\").amount(40)\n                dsl.if(\"wow?\", [\"yup\"], [\"nope\"]).then(account => {\n                    account.party(\"alice\").pays(\"carol\").amount(30)\n                    account.party(\"carol\").pays(\"alice\").amount(5)\n                    \n                }).else(account => {\n                    account.party(\"carol\").pays(\"alice\").amount(30) \n                })\n            }\n        })).multiple(\"alice\", \"bob\", \"carol\").enumerateWithBoundMulti([[1000, 2000], [1000, 2000], [1000, 2000]])\n        console.log(multi)\n\n        const multi2 = await (new Dsl (async dsl => {\n            const dates = [\"today\", \"tomorrow\", \"next week\", \"next month\"]\n            const capitalisationDates = new Set([\"next week\"])\n            const notional = 10000\n            const floatingLegIndex = \"interest rate index?\"\n            const fixedRate = 0.990382835 //I don't think it converges under this quantisation step\n            const quantisationStep = 1\n\n            dates.reduce(([capitalisation1, capitalisation2], date) => {\n                const [floatingRate, accounts] = dsl.unsafe.numeric\n                    .outcome(floatingLegIndex, 0, 1, quantisationStep, {date})\n                    .valueWithPaymentCtxUnsafe()\n\n                if (capitalisationDates.has(date)) {\n                    const floatingPayout = (notional + capitalisation1) * (floatingRate / 100) \n                    const fixedPayout = (notional + capitalisation2) * (fixedRate / 100)\n                    accounts.party(\"alice\").pays(\"bob\").amount(floatingPayout)\n                    accounts.party(\"bob\").pays(\"alice\").amount(fixedPayout) \n                    console.log(\"!!!!!\" + (floatingPayout - fixedPayout) + \" ==> \" + JSON.stringify(dsl[\"aliceTrackers\"]))\n                    accounts.release()\n                    return [0, 0]\n                } else {   \n                    accounts.release()\n                    return [\n                        notional * (floatingRate / 100) + capitalisation1, \n                        notional * (fixedRate / 100) + capitalisation2\n                    ]\n                }\n            }, [0,0])\n        })).multiple(\"alice\", \"bob\").enumerateWithBoundMulti([[50000, 20000]])\n        console.log(multi2)\n\n        const assets = await (new Dsl (async dsl => {\n            if (dsl.outcome(\"really?\", [\"YES\"], [\"NO\"])) {\n                dsl.party(\"alice\", \"usd\").pays(\"bob\", \"btc\").amount(10000000, \"usd\")\n            } else {\n                dsl.party(\"bob\", \"btc\").pays(\"alice\", \"usd\").amount(10, \"btc\")\n            }\n        })).multiple(Dsl.account(\"alice\", \"usd\"), Dsl.account(\"bob\", \"btc\")).enumerateWithBoundMulti([[1000000000, 20000]])\n        console.log(assets)\n\n        const swap = await (new Dsl (async dsl => {\n            dsl.atomicSwap.ifTruth(\"lock1\", \"allowed\").then(pay => {\n                dsl.atomicSwap.ifTruth(\"lock12\", \"allowed\").then(pay => {\n                    pay.party(\"bob\", \"btc\").pays(\"alice\", \"usd\").amount(10, \"btc\")\n                }).else(() => {})\n                pay.party(\"alice\", \"usd\").pays(\"bob\", \"btc\").amount(10000000, \"usd\")\n                \n            }).else(pay => {\n                pay.party(\"bob\", \"btc\").pays(\"alice\", \"usd\").amount(10, \"btc\")\n            })\n            dsl.unsafe.numeric.outcome(\"???\", 0, 3).evaluate(x => {\n                dsl.pay(Dsl.Alice, 10)\n            })\n            dsl.numeric.infinity.bounded(100).perpetual(0, (x, st) => {\n                //return dsl.infinity.move\n                return dsl.infinity.stop\n            })\n            dsl.unsafe.numeric.infinity.bounded(100).perpetual({\"alice\": 100, \"bob\": 100}, (x, st) => {\n                const shouldnot = dsl.unsafe.infinity.move([{\n                    alice: st.alice - 1,\n                    bob: st.bob - 2\n                }, [\n                    {\n                        from: [\"alice\", \"usd\"],\n                        to: [\"bob\", \"btc\"],\n                        amount: 1\n                    },\n                    {\n                        from: [\"bob\", \"btc\"],\n                        to: [\"alice\", \"usd\"],\n                        amount: 2\n                    }\n                ]])\n                return dsl.unsafe.infinity.stop([])\n            })\n        })).multiple(Dsl.account(\"alice\", \"usd\"), Dsl.account(\"bob\", \"btc\")).enumerateWithBoundMulti([[10000000000, 200000]])\n        console.log(swap)\n\n        const turing = (a: number) => () => {\n            if (a > 5) {\n                return 7\n            } else {\n                return Dsl.recurse.bounded(turing(a)).attempts(30).otherwiseYield(50)()\n            }\n        }\n        console.log(turing(7)())\n        console.log(turing(1)())\n\n        console.log(\"OK!\")\n    })()\n}", "import Sandbox from \"@nyariv/sandboxjs\";\nimport { Dsl } from \"../dsl\";\n\ndeclare global {\n    interface Window {\n        evalDiscreet: (expression: string, parties: string[], bounds: [number, number][]) => Promise<any>\n    }\n}\n\nexport const evalDiscreet = async (expression: string, parties: string[], bounds: [number, number][]): Promise<any> => {\n    \n    const model = await (new Dsl(async dsl => {\n        const prototypeWhitelist = Sandbox.SAFE_PROTOTYPES;\n        const globals = {...Sandbox.SAFE_GLOBALS, alert};\n        prototypeWhitelist.set(Dsl, new Set());\n\n        const sandbox = new Sandbox({globals, prototypeWhitelist})\n        const exec = sandbox.compile(expression)\n    \n        exec({dsl, Dsl}).run()\n    }).multiple(...parties).enumerateWithBoundMulti(bounds))\n    return model\n}\n\nwindow.evalDiscreet = evalDiscreet"],
  "mappings": "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",
  "names": ["SandboxGlobal", "globals", "globalThis", "i", "this", "ExecContext", "constructor", "ctx", "constants", "tree", "getSubscriptions", "setSubscriptions", "changeSubscriptions", "setSubscriptionsGlobal", "changeSubscriptionsGlobal", "evals", "registerSandboxFunction", "allowJit", "evalContext", "createContext", "sandbox", "options", "sandboxGlobal", "context", "globalsWhitelist", "Set", "Object", "values", "prototypeWhitelist", "Map", "map", "a", "prototype", "globalScope", "Scope", "set", "getPrototypeOf", "Symbol", "iterator", "createExecContext", "executionTree", "execContext", "WeakMap", "fn", "sandboxFunctions", "func", "sandboxFunction", "Function", "eval", "sandboxedEval", "setTimeout", "sandboxedSetTimeout", "setInterval", "sandboxedSetInterval", "CodeString", "str", "ref", "start", "end", "length", "substring", "code", "len", "char", "toString", "trimStart", "found", "exec", "slice", "trim", "valueOf", "keysOnly", "obj", "ret", "assign", "key", "reservedWords", "parent", "vars", "functionThis", "const", "let", "var", "isFuncScope", "allVars", "get", "functionScope", "Prop", "has", "SyntaxError", "hasOwnProperty", "val", "prop", "ReferenceError", "isConst", "TypeError", "isGlobal", "SandboxError", "declare", "type", "value", "undefined", "LocalScope", "Error", "isLisp", "item", "Array", "isArray", "isVariable", "forEach", "cb", "ExecReturn", "auditReport", "result", "returned", "breakLoop", "continueLoop", "optional", "generateArgs", "argNames", "args", "arg", "startsWith", "sandboxedFunctions", "WeakSet", "createFunction", "parsed", "ticks", "scope", "name", "forbidFunctionCreation", "executeTree", "add", "createFunctionAsync", "Promise", "async", "executeTreeAsync", "assignCheck", "op", "arrayChange", "push", "pop", "shift", "unshift", "splice", "reverse", "sort", "copyWithin", "KeyVal", "SpreadObject", "SpreadArray", "If", "t", "f", "literalRegex", "ops", "addOps", "valueOrProp", "execMany", "done", "inLoopOrSwitch", "execSync", "_execManySync", "_execManyAsync", "catch", "res", "syncDone", "d", "e", "ad", "asyncDone", "execAsync", "isInstant", "instant", "p", "callback", "resolve", "reject", "err", "r", "doneOriginal", "_execNoneRecurse", "bobj", "b", "audit", "globalsAccess", "rep", "Number", "String", "Boolean", "isFunction", "prototypeAccess", "prot", "includes", "whitelist", "replace", "prototypeReplacements", "size", "constuctor", "g", "forbidFunctionCalls", "vals", "flat", "JSON", "stringify", "cache", "recurse", "x", "y", "keys", "change", "changed", "added", "removed", "startIndex", "deleteCount", "Math", "min", "endIndex", "NaN", "Infinity", "BigInt", "strings", "parseInt", "reg", "regexes", "RegExp", "regex", "flags", "literals", "js", "resnums", "processed", "reses", "num", "match", "$$", "$", "lispifyFunction", "isAsync", "checkFirst", "startInternal", "getIterator", "startStep", "step", "condition", "beforeStep", "loop", "loopScope", "internalVars", "$$obj", "interalScope", "innerLoopVars", "toTest", "isTrue", "caseItem", "exception", "catchBody", "finallyBody", "executeTreeWithDone", "unexecTypes", "currentTicks", "current", "executionQuota", "onExecutionQuotaReached", "scopes", "s", "_executeWithDoneSync", "_executeWithDoneAsync", "parseHexToInt", "hex", "validateAndParseHex", "errorName", "enforcedLength", "parsedHex", "isNaN", "parseHexadecimalCode", "parsedCode", "fromCharCode", "parseUnicodeCode", "surrogateCode", "parsedSurrogateCode", "isCurlyBraced", "text", "charAt", "parseUnicodeCodePointCode", "codePoint", "fromCodePoint", "RangeError", "singleCharacterEscapes", "parseSingleCharacterCode", "escapeMatch", "unraw", "raw", "_", "backslash", "unicodeWithSurrogate", "surrogate", "unicode", "octal", "singleCharacter", "createLisp", "NullLisp", "lispTypes", "ParseError", "message", "super", "lastType", "inlineIfElse", "elseIf", "ifElse", "space", "expectTypes", "splitter", "types", "opHigh", "comparitor", "boolOp", "bitwise", "next", "inlineIf", "assignment", "assignModify", "incrementerBefore", "expEdge", "call", "incrementerAfter", "modifier", "not", "inverse", "negative", "positive", "typeof", "delete", "dot", "arrayProp", "createObject", "createArray", "number", "string", "literal", "boolean", "null", "und", "arrowFunctionSingle", "arrowFunction", "inlineFunction", "group", "void", "await", "new", "initialize", "return", "throw", "spreadObject", "spreadArray", "expEnd", "expFunction", "function", "expSingle", "for", "do", "while", "loopAction", "if", "try", "block", "switch", "closings", "testMultiple", "tests", "emptyString", "okFirstChars", "aNumber", "wordReg", "semiColon", "insertedSemicolons", "quoteCache", "restOfExp", "part", "quote", "firstOpening", "closingsTests", "details", "words", "isStart", "hasSemiTest", "filter", "insertedSemis", "escape", "lastChar", "isOneLiner", "lastInertedSemi", "skip", "regRes", "foundWord", "foundNumber", "sub", "lastAnyWord", "lastWord", "test", "oneliner", "startingExecpted", "setLispType", "closingsCreate", "typesCreate", "expect", "extract", "l", "funcFound", "lispifyExpr", "lispify", "lisptype", "lispTree", "modifierTypes", "incrementTypes", "adderTypes", "instanceof", "in", "opTypes", "extractIfElse", "foundTrue", "elseReg", "count", "foundElse", "first", "all", "max", "true", "false", "quoteCount", "ie", "startTrue", "trueBlock", "elseBlock", "lispifyBlock", "indexOf", "caseFound", "statement", "insertSemicolons", "caseTest", "cases", "defaultFound", "cond", "bracketFound", "exprs", "notEmpty", "index", "matches", "lt", "isArrow", "isReturn", "argPos", "split", "ended", "eager", "iteratorRegex", "body", "lispifyReturnExpr", "extract2", "k", "ofStart2", "ofStart3", "ofCondition", "ofStep", "inStart2", "inStart3", "inStep", "inCondition", "isBlock", "catchReg", "catchRes", "offset", "argsString", "j", "expected", "topLevel", "startingExpectedWithoutSingle", "subExpressions", "pos", "defined", "expression", "parts", "skipped", "isInserted", "hoist", "it", "closingsNoInsertion", "colonsRegex", "rest", "inserted", "valid", "edge", "checkRegex", "cancel", "after", "notDivide", "possibleDivide", "extractConstants", "currentEnclosure", "regexFound", "comment", "commentStart", "currJs", "strRes", "enclosures", "isPossibleDivide", "li", "join", "tempJsStrings", "parse", "createEvalContext", "SandboxFunction", "params", "handler", "subscribeSet", "names", "callbacks", "changeCbs", "unsubscribe", "SandboxExec", "opt", "SAFE_GLOBALS", "SAFE_PROTOTYPES", "console", "debug", "error", "info", "log", "table", "warn", "isFinite", "parseFloat", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "unescape", "EvalError", "URIError", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "Intl", "Date", "protos", "proto", "subscribeGet", "subscribeSetGlobal", "getContext", "Sandbox", "static", "getOwnPropertyNames", "compile", "optimize", "run", "compileAsync", "then", "compileExpression", "compileExpressionAsync", "DslErrors", "pubkeyUnique", "handler", "h", "party", "sum", "funds", "counterparty", "pay"]
}
